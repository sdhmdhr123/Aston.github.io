<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aston</title>
  
  <subtitle>记录学习的技能以及平时的感悟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sdhmdhr123.github.io/"/>
  <updated>2018-04-16T13:22:33.098Z</updated>
  <id>http://sdhmdhr123.github.io/</id>
  
  <author>
    <name>Aston</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github+hexo插入本地图片方法</title>
    <link href="http://sdhmdhr123.github.io/2018/04/16/github-hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95/"/>
    <id>http://sdhmdhr123.github.io/2018/04/16/github-hexo插入图片方法/</id>
    <published>2018-04-16T13:11:31.000Z</published>
    <updated>2018-04-16T13:22:33.098Z</updated>
    
    <content type="html"><![CDATA[<p>用markdown+hexo传到github这一套写博客的话感觉挺帅的，但是我发现有一个巨大的坑，就是在使用本地图片时，传到github就没法用了。</p><p>搜了半天，发现最简便的方法就是把_config.yml的 create_asset_folder 改成true，然后安装一个插件（我看了一眼我那个代码好像并没有安装成功，反正能用），这样在建立文章时就会随之产生一个文件夹，你把图片放进去，然后在写文章的时候直接写<code>[example](filename/test.png)</code>就可以了。</p><p>但是我感觉这样还是很麻烦，这里有一个markdown编辑神器，typora，可以拖拽插入图片，如果是网络上的图片就直接插入进去了，但如果是本地的，typora有三个选项，一个是生成<code>./pic.png</code> 、<code>asset/pc.png</code>、<code>filename.asset/pic.png</code>。</p><p>由于我发现你只要把图片放在那个同名文件夹内，传到github里面你的文章和图片就会在一个文件夹里了，所以你只要在用typora时选第一个<code>./pic.png</code> 然后把这些图片复制到同名文件夹中就可以了。</p><p>如果你不需要上传到github，你可以利用typora导出pdf格式，非常好用！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用markdown+hexo传到github这一套写博客的话感觉挺帅的，但是我发现有一个巨大的坑，就是在使用本地图片时，传到github就没法用了。&lt;/p&gt;
&lt;p&gt;搜了半天，发现最简便的方法就是把_config.yml的 create_asset_folder 改成true
      
    
    </summary>
    
      <category term="学习" scheme="http://sdhmdhr123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>科研（一）</title>
    <link href="http://sdhmdhr123.github.io/2018/04/16/%E7%A7%91%E7%A0%94%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://sdhmdhr123.github.io/2018/04/16/科研（一）/</id>
    <published>2018-04-16T12:47:29.000Z</published>
    <updated>2018-04-16T14:51:48.683Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="数据信息"><a href="#数据信息" class="headerlink" title="数据信息"></a>数据信息</h1><p><a href="https://www.physionet.org/challenge/2018/" target="_blank" rel="noopener">physionet</a></p><p>2018年PhysioNet /计算机心脏病学挑战的数据由麻省总医院（MGH）计算临床神经生理学实验室（CCNL）和临床数据动画实验室（CDAC）提供。 该数据集包括在MGH睡眠实验室监测的1,985个受试者，用于诊断睡眠障碍。 数据平衡地分为训练集（n = 994）和测试集（n = 989）。 收集的患者的临床特征和结果列于下表1中。</p><p><strong>Table 1:</strong> <em>Clinical characteristics of the dataset, and those of the training, and testing set.</em></p><table><thead><tr><th>Clinical Feature</th><th>Total(n = 1893)</th><th>Train(n = 994)</th><th>Test(n = 989)</th></tr></thead><tbody><tr><td>Age</td><td>55(+/-14.4)</td><td>55(+/-14.3)</td><td>55(+/-14.4)</td></tr><tr><td>Body Mass Index</td><td>33(+/-7.6)</td><td>33(+/-7.8)</td><td>33(+/-7.5)</td></tr><tr><td>Epworth Sleepiness Scale[1]</td><td>8.6(+/-5.3)</td><td>8.5(+/-5.3)</td><td>8.7(+/-5.3)</td></tr><tr><td>Gender (% Male)</td><td>65</td><td>67</td><td>63</td></tr><tr><td><strong>Drug Use (%)</strong></td><td></td><td></td><td></td></tr><tr><td>Antidepressant抗抑郁</td><td>26.1</td><td>25.7</td><td>26.5</td></tr><tr><td>Antihistamine 抗组胺</td><td>4.8</td><td>4.8</td><td>4.8</td></tr><tr><td>Benzodiazepine 镇静类药物</td><td>16.1</td><td>16.9</td><td>15.4</td></tr><tr><td>Diabetic 糖尿病药物</td><td>11.7</td><td>11.9</td><td>11.5</td></tr><tr><td>Herbal 草本药物</td><td>4.2</td><td>4.3</td><td>4.0</td></tr><tr><td>Hypertension 高血压类</td><td>40.9</td><td>41.0</td><td>40.6</td></tr><tr><td>Neuroleptic 安定类药物</td><td>4.2</td><td>4.5</td><td>3.8</td></tr><tr><td>Opiate 麻醉类药物</td><td>7.4</td><td>8.1</td><td>6.7</td></tr><tr><td>Neuroactive 神经兴奋类</td><td>19.1</td><td>20.8</td><td>17.5</td></tr><tr><td>Sleep aids 助睡眠类</td><td>28.3</td><td>29.0</td><td>27.8</td></tr><tr><td>Stimulant 兴奋剂</td><td>4.7</td><td>3.9</td><td>5.5</td></tr><tr><td><strong>Reason For Visit (%)</strong></td><td></td><td></td><td></td></tr><tr><td>Diagnostic (%) 就诊</td><td>41.8</td><td>41.16</td><td>42.47</td></tr><tr><td>Split Night CPAP (%) [2]</td><td>38.35</td><td>37.95</td><td>39.03</td></tr><tr><td>All Night CPAP (%)</td><td>19.85</td><td>20.88</td><td>18.5</td></tr></tbody></table><h2 id="Sleep-Stages"><a href="#Sleep-Stages" class="headerlink" title="Sleep Stages"></a>Sleep Stages</h2><p>根据美国睡眠医学学会（AASM）睡眠评分手册，MGH的临床工作人员对睡眠阶段进行了注释。 更具体而言，以下六个睡眠阶段在30秒连续间隔中被注释：wakefulness, stage 1, stage 2, stage 3, rapid eye movement (REM), and undefined.（觉醒，阶段1，阶段2，阶段3，快速眼动（REM）和未定义）。 表2列出了睡眠期间受试者的特征。</p><p><img src="/2018/04/16/科研（一）/1523840382156.png" alt="1523840382156"></p><h2 id="Arousals"><a href="#Arousals" class="headerlink" title="Arousals"></a>Arousals</h2><p>MGH认证的睡眠专家标记了会打断受试者的睡眠的唤醒所出现的波形。 注意到的觉醒分为：自然觉醒，呼吸相关觉醒（RERA），磨牙症，<strong>换气不足，低通气（hypoventilations hypopneas？区别</strong>），呼吸暂停（中枢性，阻塞性和混合性），发声，打鼾，周期性腿部运动，Cheyne-Stokes呼吸（潮式呼吸）或部分气道阻塞。</p><p><strong>Table 3:</strong> Number and types of arousals in the training set.</p><table><thead><tr><th>Target arousals</th><th></th></tr></thead><tbody><tr><td>Bruxism 磨牙</td><td>30</td></tr><tr><td>Cheyne-Stokes breathing 潮式呼吸[3]</td><td>3</td></tr><tr><td>Hypoventilation换气不足</td><td>4</td></tr><tr><td>Noise 噪音</td><td>1</td></tr><tr><td>Partial airway obstruction 部分气道堵塞</td><td>11</td></tr><tr><td>Periodic leg movement (PLM) 周期性腿动</td><td>36</td></tr><tr><td>Respiratory effort (RERA) 呼吸暂停</td><td>43,822</td></tr><tr><td>Snoring 打鼾</td><td>28</td></tr><tr><td>Spontaneous 自然觉醒</td><td>70</td></tr><tr><td>Total</td><td>44,005</td></tr><tr><td><strong>Non-target arousals</strong></td><td></td></tr><tr><td>Hypopnea 低通气</td><td>56,936</td></tr><tr><td>Central apnea</td><td>22,763</td></tr><tr><td>Mixed apnea</td><td>2,641</td></tr><tr><td>Obstructive apnea</td><td>32,547</td></tr><tr><td>Total</td><td>114,887</td></tr></tbody></table><p><strong>这个target是指标签数据还是目标数据？</strong></p><h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><p>受试者在夜间睡眠时记录各种生理信号，包括：脑电图（EEG），眼电图（EOG），肌电图（EMG），心电图（ECG）和血氧饱和度（SaO2）。 在表4中，我们列出了可用信号的完整列表。 使用国际10/20电极放置系统收集6个EEG通道（F3-M2，F4-M1，C3-M2，C4-M1，O1-M2，O2-M1）。 单导联心电图收集电极放置在胸骨附近的右锁骨下方并在左侧胸壁上方。 收集左眼EOG，将右耳EEG电极（M2）作为参考。 肌电图记录在下巴，胸部和腹部进行。 排除SaO2后，所有信号均采样至200 Hz，并以微伏测量。 为了分析方便，<strong>SaO2 was resampled to 到200Hz?</strong>，并以百分比的形式记录。</p><p><img src="/2018/04/16/科研（一）/1523841414382.png" alt="1523841414382"></p><p>为了压缩数据，所有信号都使用 the scale and offset approach从64位float转换为16位signed int。 挑战赛的数据存储在Matlab适应的WFDB信号文件中。</p><h2 id="Accessing-the-Data"><a href="#Accessing-the-Data" class="headerlink" title="Accessing the Data"></a>Accessing the Data</h2><p>数据库包含两种类数据，训练集和测试集，每个大小约为135G，每个训练集样本包含信号，头文件，唤醒文件</p><ol><li>tr03-0005.mat：包含信号数据的Matlab V4文件。</li><li>tr03-0005.hea：记录头文件 - 描述信号数据格式的文本文件。</li><li>tr03-0005.arousal：唤醒和睡眠阶段注释，采用WFDB注释格式。</li><li>tr03-0005-arousal.mat：一个Matlab V7结构的文件，包含挑战赛的睡眠阶段和目标唤醒事件，采样频率为200 Hz。</li></ol><h2 id="Data-Sample"><a href="#Data-Sample" class="headerlink" title="Data Sample"></a>Data Sample</h2><p><img src="/2018/04/16/科研（一）/1523850990475.png" alt="1523850990475"></p><p>我们可以从上图中看出，数据集包含了同一个受试者同一时间段内的14条数据，其中标签数据为第二条arousal，他会以蓝色纵向标记发生的时间点，如图中蓝线W（wakeness）代表了自然觉醒时间点，由于是人为标注，所以发生时间有误差，所以在标注点前后的信息都应纳入考量范围。</p><p><img src="/2018/04/16/科研（一）/1523860799468.png" alt="1523860799468"></p><h2 id="primary-ideas"><a href="#primary-ideas" class="headerlink" title="primary ideas"></a>primary ideas</h2><p>​    由于数据虽然进行了标注，但是并没有进行分割和分类，最好先对数据进行切割。通常ECG和通气具有周期性，可通过周期性进行分割迅练，但是其他数据并没有看到明显的周期性，所以分割方式还有待解决。</p><p>[ - ] 设想一</p><p>​    找到一种可以适应于所有这13种数据的方法，直接转变为13个输入进行训练。</p><p>[ - ] 设想二</p><p>​    对于不同种数据找到效果最好的不同方法分别训练最后投票判断特征。</p><p>[ - ] 设想三</p><p>​    首先对不同特征进行数据降维，找到与这个标签最相关的特征，然后分别进行机器学习然后，多维数据再进行设想二的方法进行学习。</p><p>[<strong>1]epworth 嗜睡量表</strong></p><p>爱泼沃斯嗜睡量表（Epworth Sleepiness Scale，ESS）是由澳大利亚墨尔本的Epworth医院设计的。临床应用结果表明，ESS是一种十分简便的患者自我评估白天嗜睡程度的问卷表。 </p><p><strong>附表：Epworth嗜睡量表（ESS）</strong></p><p>　　 在下列情况下你打瞌睡或睡着的可能性有多大？根据表中假设的8种场景，请在右边“打瞌睡的可能性”选项中做出选择：“0”代表不会打瞌睡，“1”代表打瞌睡的可能性很小，“2”代表打瞌睡的可能性中等，“3”代表很可能打瞌睡。</p><p>　　 1 坐着阅读书刊时</p><p>　　 2 看电视时</p><p>　　 3 在沉闷公共场所坐着不动时(如剧场、开会)</p><p>　　 4 连续乘坐汽车1小时无间断 5 条件允许情况下，下午躺下休息时</p><p>　　 6 坐着与人谈话时</p><p>　　 7 未饮酒午餐后安静地坐着</p><p>　　 8 遇到堵车，在停车的几分钟里</p><p>　　 注：上述分数相加得到总分。ESS评分标准为：总分0-8分正常；9-12分轻度异常；13-15分中度异常；大于16分重度异常。</p><p><strong>[2 ] CPAP</strong></p><p>持续正压通气(Continuous Positive Airway Pressure)，即用面罩将持续的正压气流送入气道．用此种方式给氧的机器称CPAP呼吸机。指在自主呼吸条件下，患者应有稳定的呼吸驱动力和适当潮气量，在整个呼吸周期内人为地施以一定程度的气道内正压，从而有利于防止气道萎陷，增加功能残气量，改善肺顺应性，并提高氧合作用。在这种模式下，呼吸机只维持一定的气道正压，不进行机械通气。仅限于有自主呼吸的患者。如果病人出现呼吸暂停，CPAP呼吸机可以根据预设的频率进行必要的机械通气，来保障患者的安全。</p><p>split night代表一开始不用呼吸机睡眠几小时，然后睡眠过程中，若果有OSAS的症状而且是中度到重度的，会弄醒你然后开始 使用呼吸机 </p><p>all night 睡觉开始时就开始用</p><p><strong>[3] 潮式呼吸</strong></p><p>潮式呼吸（Cheyne-Stokes respiration）又称陈-施呼吸，特点是呼吸逐步减弱以至停止和呼吸逐渐增强两者交替出现，周而复始，呼吸呈潮水涨落样。多见于中枢神经疾病、脑循环障碍和中毒等患者。潮式呼吸周期可长达30秒～2分钟，暂停期可持续5～30秒。</p><p>病因</p><p>一般认为是呼吸中枢对二氧化碳的反应性降低，亦即呼吸中枢兴奋的阈值高于正常值。血中二氧化碳的分压低于能兴奋呼吸中枢的阈值，因而呼吸暂停。待血中二氧化碳分压超过正常水平达到阈值时，才能兴奋呼吸中枢，使呼吸恢复，经一阵呼吸后，血中二氧化碳分压又下降到阈值水平以下，呼吸中枢又停止活动，呼吸停止。</p><p>鉴别诊断</p><p>间停呼吸又称Biots呼吸。表现为有规律的均匀呼吸几次后，停止一段时间，又开始均匀呼吸，即周而复始的间停呼吸。该呼吸与潮式呼吸不同，它每次呼吸深度相等，而非深浅起伏，呼吸暂停时间比潮式呼吸长，呼吸次数也明显减少，间停呼吸发生机制与潮式呼吸大致相同，但患者呼吸中枢抑制比潮式呼吸者更重、病情更严重，预后不良，多在呼吸完全停止前出现。引起间停呼吸的疾病与潮式呼吸大致相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;数据信息&quot;&gt;&lt;a href=&quot;#数据信息&quot; class=&quot;headerlink&quot; title=&quot;数据信息&quot;&gt;&lt;/a&gt;数据信息&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.physionet.org/challenge/2018
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git bash、cygwin、minGW、shell、cmd</title>
    <link href="http://sdhmdhr123.github.io/2018/04/12/bash%E3%80%81cygwin%E3%80%81minGW/"/>
    <id>http://sdhmdhr123.github.io/2018/04/12/bash、cygwin、minGW/</id>
    <published>2018-04-12T14:43:37.000Z</published>
    <updated>2018-04-12T14:43:37.530Z</updated>
    
    <content type="html"><![CDATA[<p>git bash、cygwin、minGW、shell</p><hr><h3 id="一天弄懂一件事"><a href="#一天弄懂一件事" class="headerlink" title="一天弄懂一件事"></a>一天弄懂一件事</h3><p>最近在装physionew的开发包（WFDB software package）时,我遇到了需要安装cygwin minGW才能安装的情况，我通过了解这两个编译环境，发现和gitbash很像。。于是乎我试了一下gitbash行不行……结果是不行的，所以他们其中的区别是什么呢？</p><p>首先我们要先了解一下这几个东西，首先先给个我个人理解上的定义便于我们总结，其实呢这几个东西都可以认作shell，一个“壳”，功能是为操作电脑硬件系统提供一个平台、一个界面，你可以从这个界面操作你的电脑执行你的命令。然后他们的不同点就是集成的操作环境不太一样，即一些操作符还有一些规则不太一样。</p><p>cmd是command的缩写，翻译过来是命令提示符，是一种基于dos系统的命令行程序，一般都在windows系统下面用，功能上基本上是这几个里面最弱的了吧。。。基本上人家有的他们有 ，他有的别的都有。</p><p>shell：是运行在linux系统的“cmd”，但是功能要强大很多，接近于一门语言。</p><p>git bash：其实是为了在cmd的基础上封装了一些unix下的命令脚本，以及一些git自己相关的脚本</p><p>cygwin：当看到cygwin的时候我一下就想到了git bash 想着能不能直接用git bash，毕竟装那么多环境我会感觉很混乱，然后试了一下，出错，说是缺少gcc包什么的，看来相比较起来，cygwin在windows模拟linux环境上还是更胜一筹。</p><p>minGW：和cygwin功能上类似，但是实现方法貌似不一样。没打算用就没过多关注。</p><hr><p>后记：cygwin占空间很大，大概10G+的样子这还是我只装了一个devel包的情况下，后来在想运行wfdb的时候，说还缺少其他的包，我就索性把它删了直接用服务器好了，但是有个致命的问题。。。最后cygwin的那个数据包竟然删不掉，原因是系统正在运行cygwin，wtf？我都删了好伐。。。看了很多文章都是说删了注册表或者用安装过程中把install改成uninstall就行，最后也不成功。。360的强力删除也不行，目前的结果只能是放任这个包占用着3G的空间不管他了，，，还好我的强迫症并不严重。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git bash、cygwin、minGW、shell&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一天弄懂一件事&quot;&gt;&lt;a href=&quot;#一天弄懂一件事&quot; class=&quot;headerlink&quot; title=&quot;一天弄懂一件事&quot;&gt;&lt;/a&gt;一天弄懂一件事&lt;/h3&gt;&lt;p&gt;最近在装physio
      
    
    </summary>
    
    
      <category term="GNU" scheme="http://sdhmdhr123.github.io/tags/GNU/"/>
    
      <category term="环境" scheme="http://sdhmdhr123.github.io/tags/%E7%8E%AF%E5%A2%83/"/>
    
      <category term="编译器" scheme="http://sdhmdhr123.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow理解</title>
    <link href="http://sdhmdhr123.github.io/2018/04/12/tensorflow%E7%90%86%E8%A7%A3/"/>
    <id>http://sdhmdhr123.github.io/2018/04/12/tensorflow理解/</id>
    <published>2018-04-12T14:42:57.000Z</published>
    <updated>2018-04-12T14:58:48.929Z</updated>
    
    <content type="html"><![CDATA[<p>以前一直没搞明白tensorflow的概念，现在好像又多了一点点理解。</p><p>tensor代表张量，但是只是保存的计算过程，并不是真正的数据，包含的内容是名称，类型，维度，但是只是一个过程，没有具体的数字。flow当然就是数据流过这些过程，然后输出一个结果。</p><p>所以呢，tensorflow的概念就是也是一个包，框架框架的感觉有点晕晕的，框架和库其实是一种抽象的描述，即框架是你可以拿来进行二次开发的一个基础，而库是一个工具箱，他们和包有点类似于平行的概念，包里可以有框架和库。</p><p>有人说了scikit-learn不也是一个机器学习包，也是封装了一些现成算法，和tensorflow有什么区别呢？诶，区别还真有，第一他是个包，所以就没有tensorflow的运算特性了，不能用GPU，所以呢就是运行比较慢。同时，就目前而言的我的理解，scikit-learn只是封装算法，你到时候可以调用，其他的该你自己写还是你自己写，而tensorflow呢是搭乐高积木，一块搭一块（但其实我感觉写起来还是自己写）。但是呢，scikit-learn的功能其实是比tensorflow更齐全的，在这个方面可以把tensorflow看成python，scikit-learn是c++，就是有点类似这么个区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前一直没搞明白tensorflow的概念，现在好像又多了一点点理解。&lt;/p&gt;
&lt;p&gt;tensor代表张量，但是只是保存的计算过程，并不是真正的数据，包含的内容是名称，类型，维度，但是只是一个过程，没有具体的数字。flow当然就是数据流过这些过程，然后输出一个结果。&lt;/p&gt;
      
    
    </summary>
    
      <category term="学习" scheme="http://sdhmdhr123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>当Conda找不到所需要的包时</title>
    <link href="http://sdhmdhr123.github.io/2018/04/12/%E5%BD%93conda%E6%89%BE%E4%B8%8D%E5%88%B0%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85%E6%97%B6/"/>
    <id>http://sdhmdhr123.github.io/2018/04/12/当conda找不到所需要的包时/</id>
    <published>2018-04-12T13:30:05.000Z</published>
    <updated>2018-04-12T13:32:30.016Z</updated>
    
    <content type="html"><![CDATA[<p>比如找不到 pyqt5<br>anaconda search -t conda pyqt5<br>会得到一堆列表<br>Packages:</p><pre><code>Name                      |  Version | Package Types   | Platforms      ------------------------- |   ------ | --------------- | ---------------abergeron/pyqt5           |    5.4.1 | conda           | osx-64         andreas-h/pyqt5           |    5.3.2 | conda           | linux-64, win-64, osx-64asmeurer/pyqt5            |    5.3.2 | conda           | osx-64         astrofrog/pyqt5           |    5.5.0 | conda           | linux-64  </code></pre><p>…</p><p>Run ‘anaconda show <user package="">‘ to get installation details<br>(my_research) root@iZwz9194z8s66bnyjsuuagZ:~# anaconda show conda-forge/wfdb</user></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;比如找不到 pyqt5&lt;br&gt;anaconda search -t conda pyqt5&lt;br&gt;会得到一堆列表&lt;br&gt;Packages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Name                      |  Version | Package Types
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下的fish</title>
    <link href="http://sdhmdhr123.github.io/2018/04/12/fish/"/>
    <id>http://sdhmdhr123.github.io/2018/04/12/fish/</id>
    <published>2018-04-12T12:47:39.000Z</published>
    <updated>2018-04-16T02:44:31.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Fish 是”the friendly interactive shell”的简称，最大特点就是方便易用。很多其他 Shell 需要配置才有的功能，Fish 默认提供，不需要任何配置。</p><p>如果你想拥有一个方便好用的 Shell，又不想学习一大堆语法，或者花费很多时间配置，那么你一定要尝试一下 Fish。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017050204.png" alt="img"></p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>Ubuntu 和 Debian 的安装方法。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ sudo apt-get install fish</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>Mac 的安装方法。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ brew install fish</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>其他系统的安装请参考<a href="http://fishshell.com/#platform_tabs" target="_blank" rel="noopener">官方网站</a>。</p><h2 id="三、启动与帮助"><a href="#三、启动与帮助" class="headerlink" title="三、启动与帮助"></a>三、启动与帮助</h2><p>安装完成后，就可以启动 Fish。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ fish</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>由于 Fish 的语法与 Bash 有很大差异，Bash 脚本一般不兼容。因此，我建议不要将 Fish 设为默认 Shell，而是每次手动启动它。</p><p>使用过程中，如果需要帮助，可以输入<code>help</code>命令。浏览器就会自动打开，显示在线文档。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ <span class="built_in">help</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="四、彩色显示"><a href="#四、彩色显示" class="headerlink" title="四、彩色显示"></a>四、彩色显示</h2><p>进入 Fish 以后，你注意到的第一件事，可能就是它默认彩色显示。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 无效命令为红色</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ mkd</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 有效命令为蓝色</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ mkdir</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>有效路径会有下划线。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ cat ~/somefi </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码表示，存在以<code>~/somefi</code>开头的路径。如果没有下划线，你就知道这个路径不存在。</p><h2 id="五、自动建议"><a href="#五、自动建议" class="headerlink" title="五、自动建议"></a>五、自动建议</h2><p>Fish 会自动在光标后面给出建议，表示可能的选项，颜色为灰色。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 命令建议</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ /bin/hostname</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 参数建议</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ grep --ignore-case</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 路径建议</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ ls node_modules</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>如果采纳建议，可以按下<code>→</code>或<code>Control + F</code>。如果只采纳一部分，可以按下<code>Alt + →</code>。</p><h2 id="六、自动补全"><a href="#六、自动补全" class="headerlink" title="六、自动补全"></a>六、自动补全</h2><p>输入命令时，Fish 会自动显示匹配的上一条历史记录。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git commit -m <span class="string">"feat: first commit"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>如果没有匹配的历史记录，Fish 会猜测可能的结果，自动补全各种输入。比如，输入<code>pyt</code>再按下<code>Tab</code>，就会自动补全为<code>python</code>命令。</p><p>如果有多个可能的结果，Fish 会把它们都列出，还带有简要介绍。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ vi[按下 Tab 键]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vi (Executable link, 2.7MB)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> view (Vi IMproved, 一个程序员的文本编辑器)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> viewer.py (Executable, 967B)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> viewres  (Graphical class browser <span class="keyword">for</span> Xt)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ...and 12 more rows</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>这时，再按一次<code>tab</code>，就可以在这些命令之中选择。</p><p>除了补全命令，Fish 还可以补全参数。比如，<code>ls</code>命令的<code>-l</code>参数后面按下<code>Tab</code>键，就会显示可以连用的其他参数。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ ls -l[按下 Tab 键]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -l1  (List one file per line)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lA  (Show hidden except . and ..)  </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -la  (Show hidden)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lB  (Ignore files ending with ~)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ...and 16 more rows</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Fish 还可以自动补全 Git 分支。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>$ git checkout master<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 七、易懂的语法</span><br><span class="line"></span><br><span class="line">Fish 的语法非常自然，一眼就能看懂。</span><br><span class="line"></span><br><span class="line">`<span class="keyword">if</span>`语句。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>if grep fish /etc/shells<br>    echo Found fish<br>else if grep bash /etc/shells<br>    echo Found bash<br>else<br>    echo Got nothing<br>end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`switch`语句。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>switch (uname)<br>case Linux<br>    echo Hi Tux!<br>case Darwin<br>    echo Hi Hexley!<br>case FreeBSD NetBSD DragonFly<br>    echo Hi Beastie!<br>case ‘*’<br>    echo Hi, stranger!<br>end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`while`循环。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>while true<br>    echo “Loop forever”<br>end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`f<span class="literal">or</span>`循环。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>for file in *.txt<br>    cp $file $file.bak<br>end<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 八、函数</span></span></span><br><span class="line"></span><br><span class="line">Fish 的函数用来封装命令，或者为现有的命令起别名。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>function ll<br>    ls -lhG $argv<br>end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面代码定义了一个`ll`函数。命令行执行这个函数以后，就可以用`ll`命令替代`ls -lhG`。其中，变量`$argv`表示函数的参数。</span><br><span class="line"></span><br><span class="line">下面是另一个例子。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>function ls<br>    command ls -hG $argv<br>end<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的代码重新定义`ls`命令。注意，函数体内的`ls`之前，要加上`command`，否则会因为无限循环而报错。</span><br><span class="line"></span><br><span class="line">## 九、提示符</span><br><span class="line"></span><br><span class="line">`fish_prompt`函数用于定义命令行提示符（prompt）。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>function fish_prompt<br>    set_color purple<br>    date “+%m/%d/%y”<br>    set_color FF0<br>    echo (pwd) ‘&gt;’<br>    set_color normal<br>end<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行上面的函数以后，你的命令行提示符就会变成下面这样。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>02/06/13<br>/home/tutorial &gt;<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 十、配置</span><br><span class="line"></span><br><span class="line">Fish 的配置文件是`~/.config/fish/config.fish`，每次 Fish 启动，就会自动加载这个文件。</span><br><span class="line"></span><br><span class="line">我们可以在这个文件里面写入各种自定义函数，它们会被自动加载。比如，上面的`fish_prompt`函数就可以写在这个文件里面，这样每次启动 Fish，就会出现自定义的提示符。</span><br><span class="line"></span><br><span class="line">Fish 还提供 Web 界面配置该文件。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>$ fish_config<br>```</p></blockquote><p>输入上面的命令以后，浏览器就会自动打开本机的 8000 端口，用户可以在网页上对 Fish 进行配置，比如选择提示符和配色主题。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017050203.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;Fish 是”the friendly interactive shell”的简称，最大特点就是方便易用。很多其他 Shel
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>应聘华为实习生</title>
    <link href="http://sdhmdhr123.github.io/2018/04/02/%E5%BA%94%E8%81%98%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    <id>http://sdhmdhr123.github.io/2018/04/02/应聘华为实习生/</id>
    <published>2018-04-02T05:49:14.000Z</published>
    <updated>2018-04-12T14:58:01.093Z</updated>
    
    <content type="html"><![CDATA[<p>华为实习生应聘经历、</p><hr><p>今年大概3月份吧，华为应该是最早的来我们学校来宣讲的，宣讲的时候讲了好多优惠条件，比如实习工资6000、面试笔试不过不影响秋招，面试过了不去到秋招的时候也可以免去前面步骤直接终面。同时由于我老师又不管我，所以打算试一试找个研发岗的实习。</p><p>大概在截止日之前我提交了自己的简历，emm……生物狗转行，申算法工程师，项目经历和实践经历都是空白，只填了个人信息和教育经历。不过还得说母校牌子是真滴好用，没几天就通知我笔试。</p><p>###笔试</p><p>说起笔试，还是有点波折的，一开始华为发给我的笔试通知附带了模拟题和最后实际操作的链接，我看了一眼模拟题，竟然有只允许用C写的程序，瞬间就没有斗志了，又考虑到笔试那天晚上有课，就选了不参加。   后来打听了一下其他的同学应聘这个岗的，发现他们也都不会做，而且说三道题只要做对一道就可以。。。。。。。wtf，我以为正常电子的或者稍微比我对口的专业写这个都该是手到擒来，结果都是摸着石头过河。。。白瞎了我对他们对口专业学生的仰望。。。。</p><p>不过还好，因为我上次选择了不参加，华为又发了一封邮件让我重新测试。emm这次其实还是没谱，但最主要的一点是我发现牛客网编程题是可以切出网页的，那就意味着有些用法可以现查，这就大大减轻了我的负担。而且人家华为又给我一次机会，这次说啥也不能不去了，虽然还是tmd周三又有课。</p><p>最后我从三个题里选了个最简单的写完了就直接交卷了，然后就去上课了。过程emm大概也就40来分钟。其实这三道题第一道我没看懂题目直接跳过，第三道其实也挺简单，但是为了上课（没错我就是这么爱学习）就也没做，反正一道就可以，点到为止，给他笔试题一个面子。后来我又看了他们第一次笔试的题，，比我的难多了，，，我命真好。。。</p><p>大概不到一周吧，面试通知就发过来了，4.1喜来登酒店建议着西装。。。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>还沉浸于过了笔试的喜悦之中的我收集了一下算法岗的面试题的范围。。。。。。。也太多了把，混过了笔试还有这么难的面试，通知和面试时间隔了两天半，我打算趁此突击一下。</p><p>第一天，充满干劲，哇这个好厉害，可能考，哇那个好厉害，也可能考</p><p>第二天……看个球……弃疗，还是打游戏把。。。</p><p>不过还好，我还有一手，因为我是下午面试，所以能跟上午的同学问问大概问的啥。有一个同学告诉我他的题目是手写遍历二叉树，然后在排个序。还有一个是弄一个网络，<em>&amp;</em>&amp;！？？？**（——（&amp;&amp;  根本没看懂，也没记住，虽然已经弃疗了，我还是抱着侥幸心理看了一下python的二叉树遍历和实现，然后自己写了个冒泡和快排，然后我表示我已经尽力了，三分天注定，七分靠打拼，剩下的90分就看脸了。</p><p>华为通知写了个建议着西装，我借了半天也没借全一套。心一横：哥是谁，就是这么特立独行。我穿着休闲装去了。。。去了之后发现4/5都是西装革履，，，</p><p>去的过程中，还和同行的同学聊了一下，他说二叉树很简单呀，我可以发你看一下，然后我就又看了一遍。到了面试现场，之前和我一直有联系的HR小哥人特别好，跟我聊了聊，说别紧张，没事，就是考冒泡二叉树之类的，你放轻松，稍微准备准备就行，所以我就叒看了一遍二叉树。结果你猜怎么，<strong>TMD还真就考了二叉树</strong> ，我的运气是真的好。。。。。</p><p>不过也不仅仅是二叉树了，二叉树之后又写了两个变形，排了一下序，又填充了一下二叉树，还用上了我现看的队列。。（我是真的运气好）。过程中面试官见到我的简历都很尴尬，没什么问的，就只能让我写算法。。。所以我一面很快，二十分钟就完了，正常有项目的话大概30分钟以上。</p><p>然后就是二面了，基本就是聊了聊基本情况，聊了一下科研和工作意向啥的。具体细节也忘了，虽然面试官笑呵呵的，但是我对他印象不是很好，可能是他在考察我什么东西所以有些问题问的比较尖锐把。</p><p>再后来说让我回来等信息，我听说大概两周才有结果吧，华为面试就告一段落了。。<strong>然而，我又收到了4.3笔试网易测试工程师的通知…………</strong></p><hr><p>更新：华为面试没过。。。。我当时面完感觉还可以，现在分析分析原因可能是没带简历，电子简历上也没填任何经历。导致印象不好吧。还有就是笔试因为有课我并没有全做，只做了一个。再找其他原因可能是性格测试和面试官当时问的问题并没有给出他想要的答案吧。。。。反正是G了。。果然面试还是很难得。</p><p>顺带提一句网易游戏的机试题是真的难。。。感觉这个暑期估计没得实习可以去了，初步打算好好搞个科研，秋招再找一下工作吧。找不到就积极准备选调生，毕竟这个应该不需要太多的实习经历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;华为实习生应聘经历、&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今年大概3月份吧，华为应该是最早的来我们学校来宣讲的，宣讲的时候讲了好多优惠条件，比如实习工资6000、面试笔试不过不影响秋招，面试过了不去到秋招的时候也可以免去前面步骤直接终面。同时由于我老师又不管我，所以打算试一试找个研发岗
      
    
    </summary>
    
      <category term="感悟" scheme="http://sdhmdhr123.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="实习" scheme="http://sdhmdhr123.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="面试" scheme="http://sdhmdhr123.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>写文章也太麻烦了</title>
    <link href="http://sdhmdhr123.github.io/2018/03/27/%E5%86%99%E6%96%87%E7%AB%A0%E4%B9%9F%E5%A4%AA%E9%BA%BB%E7%83%A6%E4%BA%86/"/>
    <id>http://sdhmdhr123.github.io/2018/03/27/写文章也太麻烦了/</id>
    <published>2018-03-27T13:18:06.000Z</published>
    <updated>2018-03-27T13:44:06.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写了几篇博客才发现，写技术博客是真滴难"><a href="#写了几篇博客才发现，写技术博客是真滴难" class="headerlink" title="写了几篇博客才发现，写技术博客是真滴难"></a>写了几篇博客才发现，写技术博客是真滴难</h2><p>本来是打算平时写写技术博客，记录一下自己学习的东西，除了方便查阅，和其他人分享一下经验与遇到的坑，最主要的用途其实还是面试的时候“啪”往面试官脸上一拍，露出“绝世强者”的笑容。</p><p>但写了几天才发现，写博客是真滴难。有可能是我自己太菜的原因，看到什么不会的都想解释一番，一写就是半小时，一写就是半小时，结果几天下来，自己的项目和学习的进度及其缓慢。内容的宽度倒是挺宽，杂七杂八啥都有，但是就是没有个有用的。在一个就是我这些写的基本都是自己纯手打，除了部分段落和代码是粘贴的，几乎每篇我都自己加了自己的理解，所以导致一天除了学习，有一半时间都用来记录了，成为了一名光荣的打字员。</p><p>所以就以上情况，我觉得是时候改变自己博客的写作方向了。给博客制定一些明确的规则和风格。</p><ol><li>网上资料特别丰富的教程及技术的方向就不记录了，例如我之前写的那个hexo建博客的那篇，感觉就没啥用，写的还没人全。不过呢，可以记录一下技术及方法，直接粘过来，当做字典用。这一类category全部命名 ”参考“。</li><li>英语类直接取消，从薄荷阅读荡下来感觉比抄写效率还低，直接放弃。</li><li>每天用于记录的时间保持在所有学习时间的1/5左右，写作原则——简洁，不要夹带自己那么多私货。</li><li>技术博客主要记录三方面：自己的项目、学习总结、按照别人方案搞遇到的坑。category 命名 “技术博文”</li><li>大方向上，只保持三个板块：技术博文，参考，感悟。</li></ol><p>嗯，总结的差不多了，感觉明天又是朝气满满的一天呢。</p><p>ps：感觉自己这种阶段性flag经常立，经常崩，经常搞着搞着偏离的主线，时间紧任务重，毕业好难。</p><p>再立个flag，实习能找就找，找不到安心自学，在毕业之前没实习没工作至少把项目做好一点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写了几篇博客才发现，写技术博客是真滴难&quot;&gt;&lt;a href=&quot;#写了几篇博客才发现，写技术博客是真滴难&quot; class=&quot;headerlink&quot; title=&quot;写了几篇博客才发现，写技术博客是真滴难&quot;&gt;&lt;/a&gt;写了几篇博客才发现，写技术博客是真滴难&lt;/h2&gt;&lt;p&gt;本来
      
    
    </summary>
    
      <category term="感悟" scheme="http://sdhmdhr123.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="烦" scheme="http://sdhmdhr123.github.io/tags/%E7%83%A6/"/>
    
  </entry>
  
  <entry>
    <title>类和对象</title>
    <link href="http://sdhmdhr123.github.io/2018/03/27/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sdhmdhr123.github.io/2018/03/27/类和对象/</id>
    <published>2018-03-27T11:29:25.393Z</published>
    <updated>2018-03-27T13:59:28.608Z</updated>
    
    <content type="html"><![CDATA[<p>对象（object）<br>广义上是指内存上一段有意义的区域。<br>狭义上是指把一组数据结构和处理他们的方法结合起来叫做对象。把相同行为的对象叫做类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）/泛化(generalization)，通过多态（polymorphism）实现基于对象类型的动态分派。<br>面相对象（objected oriented）<br><img src="https://pic7.zhimg.com/80/664ba37eeee9f4623c06c066867f1d38_hd.jpg" alt="example1"><br>类：可以理解为可以量产对象，但是产生的可以不同<br>封装：就是知道名字可以使用，但是具体怎么实现的不知道<br>继承：子类能继承父类的功能例如<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Mylist</span>(<span class="title">list</span>):</span></span><br><span class="line"><span class="class">pass</span></span><br><span class="line"><span class="class">a = <span class="type">Mylist</span>()</span></span><br><span class="line"><span class="class">a.append(5)</span></span><br><span class="line"><span class="class">这里<span class="type">Mylist</span> 就继承了list的功能。</span></span><br></pre></td></tr></table></figure></p><p>目前就我的理解，可以把类比作汽车，那停和启动就是方法，函数中通常不会封装数据，只是执行某种功能但是类中有。<br>多态：是同一个功能函数在不同的类里执行的功能可能不同（我感觉这就是废话，为什么会当成一个特征。）<br>python中的类的self其实就是相当于c++的this指针，对象自身会当做第一个参数传给self，self相当于每个房子的门牌号。类相当于设计图纸。对象就是长得很像但不是一个的房子。类：都是人，对象：但人又都不相同<br>类中可以内置一些方法，用双下横线包围<br><code>__init__(self，param1,param2=&#39;example&#39;)</code><br>你不写他也有个<code>__init__(self)</code><br>和c++的构造函数一样<br>name mangling:在私有变量或者函数前面加上两个_就可以了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">__name =<span class="string">"小甲鱼"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">returen <span class="keyword">self</span>.__name</span><br></pre></td></tr></table></figure></p><p>直接调用 p.<strong>name是不行的<br>用p.getName() p._Person</strong>name就行  python类没有权限控制，所以是伪私有。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climb</span><span class="params">(<span class="keyword">self</span>)</span></span>:  </span><br><span class="line">print(<span class="string">'ddasdfa'</span>)</span><br></pre></td></tr></table></figure><ul><li>当程序员不想把同一段代码写几次，他们发明了函数解决了这种情况。当程序员已经有了一个类，而又想建立一个非常相近的类，可以用继承的方法。  </li><li>self是对象自身作为的第一个参数传入。  </li><li>如果我们不希望对象的属性和方法被外部直接引用，我们可以设置私有变量或者函数，但实际上还是引用的到。  </li><li>类在实例化后<strong>init</strong>(self)函数会被自动调用，init 是initialize的缩写。  </li></ul><p>继承中,子类方法如果和父类方法（即函数）重名，则子类方法会把父类方法给覆盖掉。所以这里面有两种技术可以实现不覆盖。一种是<br><code>Fish.__init__(self)</code>调用父类fish，其实就等于<code>Fish.__init__(shark)</code>,shark 是子类方法。<br>另一个更好用得是super(),多重继承时特别好用。<code>super.__init__()</code><br>多重继承虽然很好用，但是容易引起代码混乱，所以在不确定的时候，最好不要用多重继承，会造成不可预见的bug，例如菱形继承或者叫做钻石继承，这个很致命。  </p><ul><li>继承机制为程序员带来的明显的好处就是写的代码量少了。</li><li>当子类定义了与父类相同名字的属性或方法时，python不会删除父类的方法或属性，但在对象调用子类继承父类时，其父类的方法或属性会被子类方法或属性给覆盖。</li><li>如果要屏蔽父类中的某些属性，利用覆盖机制就可以，将那条方法写在子类后面，写一个pass就可以</li><li>super超级的地方就在于不用再将父类的名字再打一遍，而且适用于多重继承。同时，由于你不用给出基类的名字，这就意味着如果你需要改变类继承关系，你只需要改变class里的父类即可。而不用去各个代码中寻找父类的名字。</li><li><strong>init</strong>(self)方法里不能有return ，因为这个方法不能反悔除None以外的任何对象，主要是用来给一些初始化定义。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, x=<span class="number">0</span>, y=<span class="number">0</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getX</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getY</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, p1, p2)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.x = p1.getX() - p2.getX()</span><br><span class="line">        <span class="keyword">self</span>.y = p1.getY() - p2.getY()</span><br><span class="line">        <span class="keyword">self</span>.len = math.sqrt(<span class="keyword">self</span>.x*<span class="keyword">self</span>.x + <span class="keyword">self</span>.y*<span class="keyword">self</span>.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLen</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.len</span><br><span class="line"></span><br><span class="line">p1 = Point(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">p2 = Point(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">line = Line(p1, p2)</span><br><span class="line">print(line.getLen())</span><br></pre></td></tr></table></figure><p>上面代码中并没有用到继承，传入line的是两个对象，对象自带属性和方法，在传入其他类后对其进行操作时可直接调用对象的方法和属性。  </p><p>###组合<br>组合是指把没有直接关系的类放在一起叫做组合, in another word,所谓组合就是把类和实例化放在一个新的类里面，这样就不用继承了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,x)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.num = x</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,y)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,x,y)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.turtle = Turtle(x)</span><br><span class="line"><span class="keyword">self</span>.fish = Fish(y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_num</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">print(<span class="string">"there were %d turtles and %d fish"</span><span class="string">%(self.turtle.num,self.fish.num)</span>) </span><br><span class="line">这里不能直接用<span class="keyword">self</span>.turtle, 因为 <span class="keyword">self</span>.turtle = Turtle(x) 是一个实例化对象，并不是一个实际的方法或属性</span><br></pre></td></tr></table></figure></p><p>###Min-in 编程机制</p><p>mixin 是一种开发模式，是一种将多个类中的功能单元进行组合利用的方式，这听起来有点像类的继承，但是不太一样。通常mixin不作为任何类的基类，也不关心和什么类一起使用，而是在运行时动态的同其他的零散的类一起组合使用。 下面提到的多继承和<strong>bases</strong>方法都是基于这个机制。</p><p>####多继承<br>Python支持多继承，即一个子类可以继承多个父类，利用这个特性，我们就可以利用mixin机制实现ab功能的组合。    </p><p>####<strong>bases</strong>  ：一种类的组合机制<br>多继承的实现会创建出新的类，在我们希望给A类添加B类的功能时，我们可以利用python元编程特性实现。<br>元编程meta-programming（这古文翻译，不懂古文的还真有点看不懂），写用来生成代码的代码。<br>感觉就是一种手工压缩代码量的感觉，元编程操作的对象是其他代码。<br>继续说多继承，举个栗子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_a</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_b</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span> </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.get_a()</span><br><span class="line">c.get_b()</span><br><span class="line"></span><br><span class="line">A.__bases__ += (B,)</span><br><span class="line">a.get_b()</span><br></pre></td></tr></table></figure></p><p>其实<strong>bases</strong>也是继承的机制，，因为<strong>bases</strong>属性存储了类的基类。因此多继承的方法也可以这样实现。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">C</span>:</span></span><br><span class="line"><span class="class">    pass</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="type">C</span>.__bases__ += (<span class="type">A</span>, <span class="type">B</span>, )</span></span><br></pre></td></tr></table></figure></p><p>还有另一种方式：插件方式，比较麻烦，如果用到，再看不迟<strong>dict</strong>。<a href="http://bbs.fishc.com/thread-48888-1-1.html" target="_blank" rel="noopener">参考链接</a></p><p> 类、类对象和实例对象。<br>类属性和类对象相互绑定，所以实例对象改变不会影响类对象，实例对象改变会覆盖类方法<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">a=C()</span><br><span class="line">b=C()</span><br><span class="line">c=C()</span><br><span class="line"><span class="selector-tag">a</span>.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="selector-tag">b</span>.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line">c.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line">c.count+=<span class="number">10</span></span><br><span class="line">c.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line">C.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line">C.count+=<span class="number">100</span></span><br><span class="line"><span class="selector-tag">a</span>.count</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="selector-tag">b</span>.count</span><br><span class="line"><span class="number">100</span></span><br><span class="line">c.count</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><ul><li>一个整形是不能调用的，属性名和方法名相同，属性会覆盖方法。  </li><li>类的定义要少吃多餐，不要在一个类中放上所有想到的方法和属性，尽量利用继承和组合机制进行扩展类。  </li><li><p>有不同的磁性的名字命名类。名词动词词性分开。  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = C()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c.x =<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c.x()</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;pyshell#24&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line">    c.x()</span><br><span class="line"><span class="symbol">TypeError:</span> <span class="string">'int'</span> object is <span class="keyword">not</span> callable</span><br></pre></td></tr></table></figure></li><li><p>什么时候用组合，什么时候用继承？<br>根据实际的应用场景确定。简单地说，组合适用于“有一个”的场景，继承适用于“是一个”的场景。例如有一个鱼，有一个猫有一个大象。鲨鱼是鱼，青瓜是瓜。 </p></li><li>类对象是什么时候产生的？<br>-当你这个类定义完的的时候，类定义就变成类对象。python是一切皆对象，可以用‘类名.属性’或‘类名.方法’来调用类对象。</li></ul><p>####设计一个跟踪一个类里有多少实例被创建的代码<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">                C.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">                C.count -= <span class="number">1</span> <span class="comment">#实际上我不懂这一段代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = C()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b = C()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = C()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; C.count</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; del a</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; C.count</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; del b, c</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; C.count</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>###与类相关的BIF（内置函数）<br>issubclass(class,classinfo)<br>一个类是自身的子类；classinfo可以使类对象组成的元组，只要class与其中任何一个候选类的子类，则返回True  </p><p>object 是所有类的子类<br>issubclass(B,object)</p><p>isinstance(object,classinfo)<br>检查是否是实例对象<br>第一个如果不传入实例对象，全是false<br>可以传入一个元组类  </p><h4 id="BIF-比较斯文的访问属性"><a href="#BIF-比较斯文的访问属性" class="headerlink" title="BIF 比较斯文的访问属性"></a>BIF 比较斯文的访问属性</h4><p>hasattr(object,’name’)<br>getattr(object,name[,default])<br>getattr(a,’x’,’你所访问的属性不存在’)<br>setattr(object,’name’,’value’)<br>delattr(object,’name’)<br>property(fget =None,fset=None,fdel=None,doc =None) 返回值是一个属性<br>a = property(getsize,setsize,delsize)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c<span class="selector-class">.a</span> = <span class="number">18</span>  </span><br><span class="line"><span class="selector-tag">del</span> c1<span class="selector-class">.a</span>  </span><br><span class="line">c.a</span><br></pre></td></tr></table></figure></p><p>property 主要功能是提供一个借口，再调用是只需要知道 a 不用知道里面改变了啥。  </p><p>###描述符<br>描述符就是将某种特殊类型的类的实例指派给另一个类的属性。<br><strong>get</strong>  <strong>set</strong> <strong>del</strong>是特殊类型<br>property就是一个描述符类。可以自己定义一个<br>instance 是实例拥有者的实例对象，owner 是实例拥有者<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myproperty</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,fget = None,fset=None,fdel =None)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.fget=fget</span><br><span class="line"><span class="keyword">self</span>.gset = gset</span><br><span class="line"><span class="keyword">self</span>.del=fdel</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(<span class="keyword">self</span>,instance,owner)</span></span>:   <span class="comment">#不赋值直接调用时</span></span><br><span class="line">reutrn <span class="keyword">self</span>.fget(instance)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(<span class="keyword">self</span>,instance,value)</span></span>:   <span class="comment">#赋值时所调用的</span></span><br><span class="line"><span class="keyword">self</span>.fset(instance,value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(<span class="keyword">self</span>,instance)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.fdel(instance)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>._x = None</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getX</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>._x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setX</span><span class="params">(<span class="keyword">self</span>,value)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>._x=value</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delX</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">del <span class="keyword">self</span>._x</span><br><span class="line">x = Myproperty(getX,setX,delX)</span><br><span class="line"><span class="comment">#可以说myproperty是x的描述符  class myproperty（）是描述符类</span></span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Celsius</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,value=<span class="number">26.0</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.value=float(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(<span class="keyword">self</span>,instance,owner)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(<span class="keyword">self</span>,instance,value)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.value = float(value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fahrenheit</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(<span class="keyword">self</span>,instance,owner)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> instance.cel*<span class="number">1.8</span>+<span class="number">32</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(<span class="keyword">self</span>,instance,value)</span></span><span class="symbol">:</span></span><br><span class="line">        instance.cel = (float(value)-<span class="number">32</span>)/<span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span>:</span></span><br><span class="line">    cel = Celsius()</span><br><span class="line">    fah = Fahrenheit()</span><br><span class="line"></span><br><span class="line">tmp=Temperate()</span><br><span class="line">tem.cel= <span class="number">30</span> 这是对Tem实例的cel属性进行赋值执行__set_<span class="number">_</span>方法</span><br><span class="line">然后instance.cel也就是是tem.cel</span><br><span class="line">也就是说这里面赋值其实都是给cel ，fah执行的只是给这个数进行了转换</span><br></pre></td></tr></table></figure><h3 id="定制序列"><a href="#定制序列" class="headerlink" title="定制序列"></a>定制序列</h3><p>协议与其他编程语言中的接口相似，他规定你哪些方法必须要定义。然而python中更像是一种指南。<br>定制序列就是定制容器，数据容器就是列表list，词典dict，元组tuple.<br>如果你希望你的容器不可修改你只需要定制 <strong>len</strong>() and <strong>getitem</strong>()<br>如果你希望你的容器可修改还得加上<strong>setitem</strong>() and <strong>delitem</strong>()<br>[x for x in arg]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象（object）&lt;br&gt;广义上是指内存上一段有意义的区域。&lt;br&gt;狭义上是指把一组数据结构和处理他们的方法结合起来叫做对象。把相同行为的对象叫做类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（sp
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
      <category term="python" scheme="http://sdhmdhr123.github.io/tags/python/"/>
    
      <category term="概念" scheme="http://sdhmdhr123.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://sdhmdhr123.github.io/2018/03/27/markdown%20grammer%20learning/"/>
    <id>http://sdhmdhr123.github.io/2018/03/27/markdown grammer learning/</id>
    <published>2018-03-27T11:29:25.392Z</published>
    <updated>2018-03-27T13:58:22.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-Grammer-Learning"><a href="#Markdown-Grammer-Learning" class="headerlink" title="Markdown Grammer Learning"></a>Markdown Grammer Learning</h1><h3 id="目标：易读易写"><a href="#目标：易读易写" class="headerlink" title="目标：易读易写"></a>目标：易读易写</h3><p>特点： 与word相比较而言极其轻量级，在操作上习惯后会觉得比word简便。在跨平台方面更出色。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”（具体意义就是可以直接往网上发不用再排版，还记得你从word往网站上发布时需要重新排版的情形吗？）。<br>简单点，用Markdown写作就是能够实现边输文字边排好版，根本用不上鼠标，根本不用苦苦地二次选中编辑，排出的版面又简约又舒适。（对我而言就是显得更帅一点，哈哈）<br>经过我的测试，不同的软件里集成的markdown语法略有区别，可能是markdown版本不同，例如我使用的markdownpad2就必须在字后面加两个空格才能分段，有道云和简书里直接敲回车就好了，大体上还是一致的。  </p><p>a trick: markdown 是一种标记语言，他名字的由来就是起源于 markup（中文意思‘标记’），类似的情况还包括 copyright 和copyleft（反版权）。</p><p><strong>语法</strong>：<a href="http://wowubuntu.com/markdown/#link/&quot;Markdown&quot;" target="_blank" rel="noopener">参考链接</a></p><p>实例1：展示两种标题语法 </p><p>一种是setext，利用底线形式，“=”是一级标题，“-”是二级标题</p><p>另一种是atx，在行首加入#（1-6个），‘#’数越多题目越大</p><p>区块则是利用“&gt;”来表示，区块还有更全面的使用方式，详情请见<a href="http://wowubuntu.com/markdown/#link/&quot;Markdown&quot;" target="_blank" rel="noopener">参考链接</a> 主要用来引用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A First Level Header</span><br><span class="line">====================</span><br><span class="line">A Second Level Header</span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"></span><br><span class="line">Now <span class="keyword">is</span> <span class="keyword">the</span> <span class="built_in">time</span> <span class="keyword">for</span> all good men <span class="keyword">to</span> come <span class="keyword">to</span></span><br><span class="line"><span class="keyword">the</span> aid <span class="keyword">of</span> their country. This <span class="keyword">is</span> just a</span><br><span class="line">regular <span class="built_in">paragraph</span>.</span><br><span class="line"></span><br><span class="line">The quick brown fox jumped <span class="keyword">over</span> <span class="keyword">the</span> lazy</span><br><span class="line">dog's <span class="keyword">back</span>.</span><br><span class="line"><span class="comment">### Header 3</span></span><br><span class="line"></span><br><span class="line">&gt; This <span class="keyword">is</span> a blockquote.</span><br><span class="line">&gt; </span><br><span class="line">&gt; This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="built_in">paragraph</span> <span class="keyword">in</span> <span class="keyword">the</span> blockquote.</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="comment">## This is an H2 in a blockquote</span></span><br></pre></td></tr></table></figure><h1 id="A-First-Level-Header"><a href="#A-First-Level-Header" class="headerlink" title="A First Level Header"></a>A First Level Header</h1><h2 id="A-Second-Level-Header"><a href="#A-Second-Level-Header" class="headerlink" title="A Second Level Header"></a>A Second Level Header</h2><p>Now is the time for all good men to come to<br>the aid of their country. This is just a<br>regular paragraph.</p><p>The quick brown fox jumped over the lazy<br>dog’s back.</p><h3 id="Header-3"><a href="#Header-3" class="headerlink" title="Header 3"></a>Header 3</h3><blockquote><p>This is a blockquote.</p><p>This is the second paragraph in the blockquote.</p><h2 id="This-is-an-H2-in-a-blockquote"><a href="#This-is-an-H2-in-a-blockquote" class="headerlink" title="This is an H2 in a blockquote"></a>This is an H2 in a blockquote</h2></blockquote><p>还有一种方式就是敲一个‘&gt;’ 后面接着打也是一样的</p><blockquote><p>比如这样<br>的下一行还是引用</p></blockquote><p>多个“&gt;&gt;&gt;”代表的层级例如</p><blockquote><p>我是大好人</p><blockquote><p>你是大好人</p><blockquote><p>他是大好人</p></blockquote></blockquote></blockquote><h3 id="修辞、强调与换行及首行空两格"><a href="#修辞、强调与换行及首行空两格" class="headerlink" title="修辞、强调与换行及首行空两格"></a><strong>修辞、强调与换行及首行空两格</strong></h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Some</span> <span class="keyword">of</span> these words *are emphasized*.</span><br><span class="line"><span class="keyword">Some</span> <span class="keyword">of</span> these words _are emphasized also_.</span><br><span class="line"><span class="keyword">Use</span> two asterisks <span class="keyword">for</span> **strong emphasis**.</span><br><span class="line"><span class="keyword">Or</span>, <span class="keyword">if</span> you prefer, __use two underscores instead__</span><br><span class="line">换行=在句子末尾敲多余两个空格+回车</span><br><span class="line">置于首行缩进。。。只有替代方法没有非常方便的方法，例如转成全角敲两个空格或者利用&amp;#<span class="number">160</span>;</span><br><span class="line">(试了一下不理想，还是老老实实敲空格吧)</span><br></pre></td></tr></table></figure><p>Some of these words <em>are emphasized also</em>.<br>Use two asterisks for <strong>strong emphasis</strong>.<br>&#160;Or, if you prefer, <strong>use two underscores instead</strong>  </p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，<strong>记住一个就可以了</strong>，使用星号jia加号和减号：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>Candy.</span><br><span class="line"><span class="bullet">* </span>Gum.</span><br><span class="line"><span class="bullet">* </span>Booze.  </span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>Candy.</span><br><span class="line"><span class="bullet">+ </span>Gum.</span><br><span class="line"><span class="bullet">+ </span>Booze.  </span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Candy.</span><br><span class="line"><span class="bullet">- </span>Gum.</span><br><span class="line"><span class="bullet">- </span>Booze.</span><br></pre></td></tr></table></figure></p><ul><li><p>Candy.  </p></li><li><p>Gum.</p></li><li>Booze.  </li></ul><ul><li>Candy.</li><li>Gum.</li><li>Booze.</li></ul><ul><li>Candy.</li><li>Gum.</li><li>Booze.  </li></ul><p>有序的列表则是使用一般的数字接着一个英文句点作为项目标记，序表也可以进行嵌套：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Red</span><br><span class="line">    <span class="number">1.</span> 嵌套</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> Green</span><br><span class="line"><span class="number">3.</span> Blue</span><br></pre></td></tr></table></figure></p><ol><li>Red  </li><li>Green</li><li>Blue</li></ol><ul><li><p>A list item.</p><p>  asdfasdaasfdasdfsdafasdfadsfdasfdasfasfdadsfgasdgdsagasdgsadgasdgasdgadfdsaffff</p></li><li><p>Another item in the list.</p></li><li>​</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>分为两种： 行内 和 链接  。 都是用角括号<a href=""></a>转换成链接的形式<br>行内形式是直接在后面用括号直接接上链接<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is an [<span class="string">example link</span>](<span class="link">http://example.com/</span>).</span><br></pre></td></tr></table></figure></p><p>This is an <a href="http://example.com/" target="_blank" rel="noopener">example link</a>.  </p><p>你也可以选择性的加上 title 属性(就是鼠标放在链接上面时出现的小框里的字)：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is an [<span class="string">example link</span>](<span class="link">http://example.com/ "With a Title"</span>).</span><br></pre></td></tr></table></figure></p><p>This is an <a href="http://example.com/" title="With a Title" target="_blank" rel="noopener">example link</a>.<br>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [<span class="string">Google</span>][<span class="symbol">1</span>] than from</span><br><span class="line">[<span class="string">Yahoo</span>][<span class="symbol">2</span>] or [<span class="string">MSN</span>][<span class="symbol">3</span>].</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">http://google.com/ "Google"</span></span><br><span class="line">[<span class="symbol">2</span>]: <span class="link">http://search.yahoo.com/ "Yahoo Search"</span></span><br><span class="line">[<span class="symbol">3</span>]: <span class="link">http://search.msn.com/ "MSN Search"</span></span><br></pre></td></tr></table></figure></p><p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>和链接的形式很像,就是在角括号前面需要多加一个“!”<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt text</span>](<span class="link">/path/to/img.jpg "Title"</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/path/to/img.jpg" alt="alt text" title="Title"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I strongly recommend against using any `&lt;blink&gt;` tags.</span><br><span class="line"></span><br><span class="line">I wish SmartyPants used named entities like `&amp;mdash;`</span><br><span class="line">instead <span class="keyword">of</span> decimal-encoded entites like `&amp;#<span class="number">8212</span>;`.</span><br></pre></td></tr></table></figure></p><p>I strongly recommend against using any <code>&lt;blink&gt;</code> tags.</p><p>I wish SmartyPants used named entities like <code>&amp;mdash;</code><br>instead of decimal-encoded entites like <code>&amp;#8212;</code>.</p><p>If you want your page to validate under XHTML 1.0 Strict,<br>you’ve got to put paragraph tags in your blockquotes:</p><p><blockquote></blockquote></p><p></p><p>For example.</p><br><br><code>There is a literal backtick (`) here.</code>  <p></p><p>A single backtick in a code span: <code>`</code></p><p>A backtick-delimited string in a code span: <code>`foo`</code></p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用  标签），你可以在星号的前面加上反斜杠：  </p><p>* literal asterisks * </p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name |<span class="string"> Academy </span>|<span class="string"> score </span></span><br><span class="line"><span class="string">- </span>|<span class="string"> :-: </span>|<span class="string"> -: </span></span><br><span class="line"><span class="string">Harry Potter </span>|<span class="string"> Gryffindor</span>|<span class="string"> 90 </span></span><br><span class="line"><span class="string">Hermione Granger </span>|<span class="string"> Gryffindor </span>|<span class="string"> 100 </span></span><br><span class="line"><span class="string">Draco Malfoy </span>|<span class="string"> Slytherin </span>|<span class="string"> 90</span></span><br><span class="line"></span><br><span class="line">|<span class="string">    a    </span>|<span class="string">       b       </span>|<span class="string">      c     </span>|</span><br><span class="line">|<span class="string">:-------:</span>|<span class="string">:------------- </span>|<span class="string"> ----------:</span>|</span><br><span class="line">|<span class="string">   居中  </span>|<span class="string">     左对齐    </span>|<span class="string">   右对齐   </span>|</span><br><span class="line">|<span class="string">=========</span>|<span class="string">===============</span>|<span class="string">============</span>|</span><br><span class="line"></span><br><span class="line">打那么多---主要是为了好看。。可以和第一个一样的形式</span><br><span class="line"></span><br><span class="line">作者：欧薇娅</span><br><span class="line">链接：https://www.jianshu.com/p/b03a8d7b1719</span><br><span class="line">來源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c</th></tr></thead><tbody><tr><td style="text-align:center">居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:center">=========</td><td style="text-align:left">===============</td><td style="text-align:right">============</td></tr></tbody></table><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:center">Academy</th><th style="text-align:right">score</th></tr></thead><tbody><tr><td style="text-align:left">Harry Potter</td><td style="text-align:center">Gryffindor</td><td style="text-align:right">90</td></tr><tr><td style="text-align:left">Hermione Granger</td><td style="text-align:center">Gryffindor</td><td style="text-align:right">100</td></tr><tr><td style="text-align:left">Draco Malfoy</td><td style="text-align:center">Slytherin</td><td style="text-align:right">90</td></tr></tbody></table><p>语法说明： </p><ol><li>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行代表一个表格行； </li><li>列与列之间用管道符号 “|” 隔开，原生方式的表格每一行的两边也要有管道符。 </li><li>可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。</li></ol><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>其实markdown是不支持视频的，现在的通用做法是调用html语言的iframe框架或者插入视频的链接。</p><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是文字……</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> [x] 选项一</span></span><br><span class="line"><span class="ruby">- [ ] 选项二  </span></span><br><span class="line"><span class="ruby">- [ ]  [选项<span class="number">3</span>]</span></span><br></pre></td></tr></table></figure><p>这是文字……</p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> [选项3]</li></ul><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**<span class="strong">*</span></span><br><span class="line"><span class="strong">---</span></span><br><span class="line"><span class="strong">*</span> * <span class="strong">*</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="*"></a><em>*</em></h2><hr><h3 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h3><p>和链接的方式有点像<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Markdown[^1]</span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">Markdown是一种纯文本标记语言        // 在文章最后面显示脚注</span></span><br></pre></td></tr></table></figure></p><p>Markdown[^1]<br>[^1]: Markdown是一种纯文本标记语言        // 在文章最后面显示脚注</p><h5 id="markdown与法不止这些，但是我看了一下其他的，很繁琐且不常用，建议碰到时在考虑学习，我记录的这些在平常记录或者写写文章就足够用了"><a href="#markdown与法不止这些，但是我看了一下其他的，很繁琐且不常用，建议碰到时在考虑学习，我记录的这些在平常记录或者写写文章就足够用了" class="headerlink" title="markdown与法不止这些，但是我看了一下其他的，很繁琐且不常用，建议碰到时在考虑学习，我记录的这些在平常记录或者写写文章就足够用了"></a>markdown与法不止这些，但是我看了一下其他的，很繁琐且不常用，建议碰到时在考虑学习，我记录的这些在平常记录或者写写文章就足够用了</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-Grammer-Learning&quot;&gt;&lt;a href=&quot;#Markdown-Grammer-Learning&quot; class=&quot;headerlink&quot; title=&quot;Markdown Grammer Learning&quot;&gt;&lt;/a&gt;Markdown Gr
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
      <category term="markdown" scheme="http://sdhmdhr123.github.io/tags/markdown/"/>
    
      <category term="概念" scheme="http://sdhmdhr123.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://sdhmdhr123.github.io/2018/03/27/hello-world/"/>
    <id>http://sdhmdhr123.github.io/2018/03/27/hello-world/</id>
    <published>2018-03-27T11:29:25.389Z</published>
    <updated>2018-03-27T13:55:27.826Z</updated>
    
    <content type="html"><![CDATA[<p>This blog is a test ,and is my first blog.</p><p>Hello, outside people </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This blog is a test ,and is my first blog.&lt;/p&gt;
&lt;p&gt;Hello, outside people &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用Github+hexo+next建立个人博客</title>
    <link href="http://sdhmdhr123.github.io/2018/03/26/%E5%88%A9%E7%94%A8github-hexo-next%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://sdhmdhr123.github.io/2018/03/26/利用github-hexo-next建立个人博客/</id>
    <published>2018-03-26T01:31:03.000Z</published>
    <updated>2018-03-27T13:59:46.754Z</updated>
    
    <content type="html"><![CDATA[<p>建立个人博客的经历真是很多很多坑啊…如果顺利的话，正常人应该两个小时就足够了，我是各种手贱折腾，捣鼓了好多天才弄完，emm…我就顺便记录一下我还记得的坑把。<br>你只需要按照我的步骤走就肯定没问题，可能你看到hexo，git什么不太懂，我会在步骤之间把其中涉及的概念我会一一解释。</p><p>首先是用自己的github（github我就不解释了啊，查阅百度，我感觉就是一个存代码的网盘，不过可以通过时间线查看版本）建立一个repository，这个就是我们存放我们博客的文件夹啦。 </p><p><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic1.png?raw=true" alt="1"></p><p>这里注册的仓库名要注意了，同学们，如果呢你想让你的博客网站叫做 yourgithubid.github.io 就要起和你的yourgithubID一样的名字的仓库，即repository name 填 username.github.io，如果呢你不在乎或者有买一个域名绑定的打算，就可以忽略，随便起一个random.github.io 之后访问可能就是这个网址了 yourgithubID.github.io/random.github.io. </p><p>建好了之后先放着，去搞hexo，hexo是一个快速简洁高效的静态博客框架，这里静态动态的意思就是，静态不会出现信息的交互，例如一直更新的天气天气预报，新闻啊啥的，存一部分乱七八糟一股脑扔到网上就不管了。博客也基本不需要动态，所以hexo是最佳选择，其实还可以用jekyll(不好用，教程少，hexo大法好)。<br>安装hexo之前得安装点hexo的环境，因为hexo是node.js编的，所以得把这个东西装上，例如你运行python脚本得装python吧。然后还要装Git，这个东西呢类似你的cmd，但是继承了一些linux shell的本领以及一些他git自己的命令，你可以忽略直接无脑装装装。</p><ul><li><a href="nodejs.org/">node.js</a></li><li><a href="git-scm.com">Git</a><br>安装完成之后，剩下就直接粘代码进git bash 里就好了。</li></ul><p>(妈的，markdown插图片真的贼鸡儿麻烦，得考虑一下别的编辑方法了)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure></p><p>可以参照官方文档安装node.js 和git 官方文档也有 </p><p><a href="hexo.io/zh-cn/docs/">hexo</a></p><p>好了，这时候看一下你的hexo安装成功了没有,在gitbash里<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$hexo</span></span></span><br></pre></td></tr></table></figure></p><p>看一下有木有东西，有东西就安装成功了，没东西你自己在翻翻文档。</p><p>下一步：建站  </p><p>名字挺唬人，其实就是建个文件夹。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init myGitPages</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myGitPages</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure></p><p>运行完之后，会出现很多文件和文件夹<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic3.png?raw=true" alt="3"><br>介绍一下主要的，themes是主题文件夹，网上有很多，我用的是next，这个一会再说。source就是你将会往你的github传的文件啦，文章图片啥的，_config.yml 是配置文件，你可以通过编辑这个文件来个性化你的博客，具体细节呢，我先写写看再决定写不写。package.json是应用程序信息。有默认配置的一些组件，可以自己根据需要添加或移除，反正我是看不懂json..就不改了。<br>scaffolds 模板文件夹。建立新文章时，hexo会根据scaffold来建立文件。其他的我也不知道干啥用的，不重要（但是不能删）。<br>好了基本弄完了，剩下的主题，你可以根据自己需要下载，hexo官网有很多，但是我感觉大部分人用的都是yilla和next，就以next为例。<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a><br>这里面有详细的使用说明，我就不细说了。<br>嗯 最后，就是要发布文章了，先杆状一个插件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure></p><p>这个插件是用来发布到git上的。<br>然后<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #形成</span><br><span class="line">hexo<span class="built_in"> server </span>#用来本地预览，这运行完会出现一个网址，你把它粘到网站里运行一下试试。 大概是localhost：4000 这种样子的。</span><br></pre></td></tr></table></figure></p><p>如果预览成功，好这还不算完，由于你要往网上传东西，你得得到人家github许可才行呀，所以接下来就是要做git的身份认证。<br><strong>SSH授权</strong><br>打开gitbash 输入ssh-keygen -t rsa 连敲三下回车<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic4.png?raw=true" alt="4"><br>这样就会在C盘用户目录下生成id_rsa和id_rsa.pub这两个文件，前者是密钥，后者是公钥，用记事本打开id_rsa.pub，复制其中的全部内容，添加到GitHub上，这样本地的id_rsa密钥就可以和GitHub上的id_rsa.pub公钥进行配对，授权成功<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic5.jpg?raw=true" alt="5"><br>SSH key添加之后，就可以在本机git bash中进行测试，输入ssh -T git@github.com进行测试，<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic6.png?raw=true" alt="6"><br>返回Hi username ！You’ve successfully ……说明你已经成功啦！</p><p><strong>修改上传设定</strong><br>还记得文件夹里的_config.yml吗<br>打开它，修改 （主义冒号后面必须跟空格）<br>deploy:<br>    type: git<br>    repo：<a href="https://github.com/username/username.github.io.git" target="_blank" rel="noopener">https://github.com/username/username.github.io.git</a><br>然后发布就可以了<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo <span class="keyword">generate</span> &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></p><p>第一次访问可能需要密码。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>我在测试各个主题的时候碰到了很多问题，例如next老师莫名崩溃说找不到什么/.swig，后来发现就是更改_config.yml时候格式不标准就GG了，所以你在改这些格式的时候，要千万注意，必须严格按照要求。</p><p>其实还有很多很细节的东西，我实在是懒得写了,都没时间搞科研了…以后如果碰到这种有很多教程的东西，我还是直接粘过来把，不过图片没法粘贴是个问题，再说再说，但是我可以帮忙回答遇到的问题，如果有人看的话。。。。。</p><p><strong><em>如果有什么问题可以留意问我哦~</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建立个人博客的经历真是很多很多坑啊…如果顺利的话，正常人应该两个小时就足够了，我是各种手贱折腾，捣鼓了好多天才弄完，emm…我就顺便记录一下我还记得的坑把。&lt;br&gt;你只需要按照我的步骤走就肯定没问题，可能你看到hexo，git什么不太懂，我会在步骤之间把其中涉及的概念我会一
      
    
    </summary>
    
      <category term="学习" scheme="http://sdhmdhr123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="github" scheme="http://sdhmdhr123.github.io/tags/github/"/>
    
      <category term="hexo" scheme="http://sdhmdhr123.github.io/tags/hexo/"/>
    
      <category term="next" scheme="http://sdhmdhr123.github.io/tags/next/"/>
    
      <category term="博客" scheme="http://sdhmdhr123.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>每天一点点（一）</title>
    <link href="http://sdhmdhr123.github.io/2018/03/26/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://sdhmdhr123.github.io/2018/03/26/每天一点点（一）/</id>
    <published>2018-03-26T00:28:38.000Z</published>
    <updated>2018-03-27T14:04:14.033Z</updated>
    
    <content type="html"><![CDATA[<p>1.「rise」：在文中指“站起来，起立”，常见意思为“上升，增长”。</p><p>原句：The gentleman half rose from his chair to greet me.  </p><p>2.「nature」：在文中的意思为“本质、性质”，常见意思为“自然”。  </p><p>原句：But also because the highly unusual nature of the story makes me…<br>例句：They asked a lot of questions about the nature of our democracy.(民主主义)<br>democratic democray democrat democratize  </p><p>3.「puff」：在文中与out组成词组「puff out one’s chest」，表示“挺起胸膛”常见意思为“喘粗气、使膨胀”。</p><p>原句：The client puffed out his chest with an appearance of some pride…<br>例句:  Henry puffed out his chest proudly.<br>Kim Sanpang puffed out his chest proudly with clapping his hands.</p><p>4.「immediately」在文中的意思是“紧靠地、贴近地”，常见的意思为“立刻，马上”。</p><p>原句：The fish that you have tattooed immediately above your right wrist( 手腕 ) could only have been done in China.<br>例句：He sat in the seat immediately in front of me. </p><p><strong><em>句子解析</em></strong></p><ol><li>“I know, my dear Watson, that you share my love of all / that is outside the normal routine of everyday life. You have shown your relish for it by the enthusiasm /which has prompted you/ to write down and, if I may say so, somewhat to embellish so many of my own little adventures.” </li></ol><p>prompt：迅速敏捷的， 促进激励  付款期限温馨提示<br>relish： 食欲 开胃小菜 调味品 盼望期待享受品味加作料  </p><p>第一句话中：「share」表示“共同拥有（某种看法、特质或经济）”，「share my love of all」则可以理解为“你同我一样喜欢”。</p><p>第二个「that」 引导的从句是修饰前面的「my love of all」。</p><p>所以这句话大意为：亲爱的Watson，我知道你同我一样喜欢破案，而不是那些日常生活中的俗套。</p><p>第二句话中：「show relish for something」表示“对…感兴趣，表现出对…的喜爱”。文中即：你对它（破案）很感兴趣。</p><p>「which」引导的从句是修饰「you have…enthusiasm」，在which从句中，「prompt sb. to do sth.」表示“激励（促使）某人做某事”。文中即：…促使你满腔热情地把这些东西都记录下来。</p><p>「if I may say so」是插入语，表示“如果我可以这样说；如蒙允许”。文中即：如果你不介意的话，我要说，你这样做是为我自己的许多小小的冒险事业增添光彩（embellish）。</p><p>所以这句话的大意为：你那么满腔热情地把这些东西都记录下来，可见你对它们很感兴趣。如果你不介意的话，我要说，你这样做是为我自己的许多小小的冒险事业增添光彩。</p><ol><li>“You will remember my saying the other day,/that for strange effects and extraordinary events, we must go to life itself, /which is always far more daring than any effort of the imagination.” </li></ol><p>这句话的主干为：You will remember my saying the other day. 即：你应该记得前几天（the other day）我说的那段话吧。</p><p>that从句部分是补充说明前面的「my saying」，其中which引导的从句是修饰前面的life itself，即：生活本身远比任何大胆想象更富有冒险性（daring）。</p><p>所以that从句部分的大意为：为了获得新奇的（strange）效果和不同寻常的（extraordinary）事件，我们必须深入生活，因为生活本身远比任何大胆想象更富有冒险性（daring）。</p><p>这段话是 Sherlock 跟Watson 对于创作与生活的一些探讨，而 Watson 对此观点暂时是持怀疑态度的，所以他后面说他当时斗胆持怀疑态度（being brave enough to express some doubts）。</p><ol><li>You have heard me remark/ that the strangest examples are very often connected not with the larger but with the smaller crimes, /and occasionally occur in cases/ where there is room for doubt /as to whether there has been a crime at all. </li></ol><p>这句话的主干为：You have heard me remark. 即：你已经听我说过（remark）… ；</p><p>在从句部分「that the strange … a crime at all」中，包含由and 构成的两个并列句子：</p><p>（1）「be connected not with…but with…」表示“和……无关，而和……有关”。其中「not…but…」表示“不是…而是…”。这句话的大意为：最奇怪的事件通常都不是那些大的犯罪活动，而是那种不起眼的犯罪。</p><p>（2）「and occasionally…crime at all」的主干为：and occasionally occur in cases. 即：而且偶尔有这样的案件。</p><p>where 引导的从句是修饰cases，其中「room」表示“可能性、余地”。「there is room for doubt as to …」则表示“对…存有疑虑，怀疑…”。文中即：怀疑是否真的有人犯了罪。</p><p>所以这句话的大意为：而且偶尔会有这样的案件，而你怀疑是不是真的有人犯了罪。</p><ol><li>“Beyond the obvious facts / that he has at some time done manual labor, that he is a Freemason, that he has been in China, and that he has done a lot of writing lately, / I can deduce nothing else.” </li></ol><p>这句话的主干为：Beyond the obvious facts I can deduced nothing else. 「beyond」表示“除…之外（用于否定句）”，这句话的意思是：除了这些显而易见的（obvious）情况之外，我推断不出别的。</p><p>「that he has… writing lately」其中包含由that引导的从句，都是解释说明「the obviously facts」，即：他干过一段时间的体力活（manual labor），是个共济会会员（Freemason），去过中国，最近（lately）写过不少东西。</p><p>拓展：「Freemason」指的是一个遍布全球的叫做 Freemasonry 的兄弟会的成员，大约18世纪的时候，一些石匠组织起了这个兄弟会，刚开始是工作上的交流，慢慢地变成了社交组织。一般这种组织都会有很多规则要遵守，而且还会有一些秘密活动或者仪式，还有个有趣的点，就是Sir Arthur Conan Doyle本人也是 Freemasonry 的成员。下图是一个典型的 Freemasonry 的标志：<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic.jpg?raw=true" alt="1"></p><p>I won’t insult your intelligence by telling you how I read that, especially as, rather against the strict rules of your organization, you use an arc-and-compass breastpin.</p><p>前半句中「insult」表示“侮辱”，文中即“我不想告诉你我是如何看出来的，这会侮辱你的智商(intelligence)”</p><p>扩展一下：「insult」也可以做名词，表示“侮辱、冒犯”。e.g. Some advertising is an insult to our intelligence. 有些广告对我们的智商是一种侮辱。</p><p>「against rules」表示违反规则，这里是说“尤其（rather）违反你们组织规则…”。</p><p>当被客户问到 Sherlock 是如何看出他是 Freemason 的时候，Sherlock 说我不想侮辱您的智商，但是您看看您不顾你们组织的严格规定，把这个圆规加直尺（共济会的标志）一样的胸针戴出来了。看来我们的Wilson 先生并不是个严格遵守共济会规定的人。</p><ol><li>TO THE RED-HEADED LEAGUE:<br>the will of the late Ezekiah Hopkins<br>…at the offices of the League, 7 Pope’s Court, Fleet Street. </li></ol><p>Wilson 先生拿出了报纸上刊登的一篇广告，说是根据已故的 Ezekiah Hopkins 的遗愿，有一个职位空缺需要招一个红头发、身心健康、21岁以上的男士，然后写上了面试的时间地点。</p><p>「late」在这里指”已故的”，比如 her late husband，她已故的丈夫；Fleet Street 这个地址是真实存在的，但现在已经找不到 Pope’s Court；另外广告中提到的 4 pounds a week 的工资，相当于现在400英镑的周薪，难怪Wilson会被这个广告吸引。1英镑=8.8857人民币元。</p><ol><li>“It is The Morning Chronicle of April 27, 1890. Just two months ago.” </li></ol><p>Sherlock 让 Watson 看看报纸的名字和日期。这里出现了写作上的一个时间偏差，报纸是4月27号的，Watson 说是两个月前的报纸，但文章开头说是秋季里的某一天，明显6月底不会是伦敦的秋季。</p><ol><li>I have a small pawnbroker’s business at Coburg Square, near the City. It’s not a very large one, and in the last few years it has not done more than just give me a living.</li></ol><p>「have a business」表示“做生意”，这句话的大意为：我在市区附近的Coburg广场做当铺生意（pawnbroker’s business）。</p><p>第二句话中：「one」指代business。not more than表示“仅仅、只不过”。这句话的大意为：生意规模不大，在过去几年仅仅可以维持生计而已。 </p><ol><li>You seem most fortunate in having an employee /who will take less than the full market price. It is not a common experience among employers. </li></ol><p>第一句话中：「be fortunate in doing sth」表示“做某事很幸运”。e.g. She felt fortunate in being able to please herself where she lived. 在自己住的地方能够随心所欲，她觉得很幸运。</p><p>who引导的从句是修饰前面的「employee」，这句话的大意为：你能以低于（less than）市价的工钱雇到一个伙计（employee），看起来可是非常幸运了。</p><p>第二句话「It is …employers.」的大意为：这在像你这样年纪的雇主（employer）当中，可不是一个寻常的事。</p><p>当说到自己的一个伙计愿意只拿一半工资，也要留在当铺工作的时候，Sherlock 说 Wilson 特别幸运（most fortunate），居然找到一个愿意拿比市价少的工资的员工，这样的经历大多数老板可不会遇到。所以 Sherlock 也关注到了这个不同寻常的现象。</p><ol><li>“He is always taking photographs when he ought to be improving his mind, and then diving down into the cellar like a rabbit into its hole to develop his pictures.</li></ol><p>「improve one’s mind」表示“振作精神”，在文中可以理解为“好好看守当铺”。文中即：当他本应好好看当铺的时候，他却总是在摄影拍照。</p><p>「like a rabbit into its hole」表示“动如脱兔”。「develop」在文中表示“冲洗”，常见的意思为“发展，形成”。文中即“然后像兔子跳回窝里一样似的冲到地下室冲洗胶片”。</p><p>这段话运用了比喻，生动形象的表现出Spaulding冲到地下室的急切之情。当他本应该振作精神（好好看当铺时候）他却总是在摄影拍照，然后像兔子跳回窝里一样似的冲到地下室冲洗胶片。</p><ol><li>We live very quietly, sir, the three of us; and we keep a roof over our heads and pay our debts, if we do nothing more. </li></ol><p>「keep a roof over our heads」 在文中可理解为“住在一个房檐下，一起生活”</p><p>【if we do nothing more】 则表示“除此之外没别的了”。</p><p>这段话的大意为：我们三个人一起过着安静的生活；我们住在一起，一起还债（pay our debts），除此之外没有别的了。</p><p><strong><em>今日短语</em></strong></p><p>call upon sb 拜访某人<br>be connected not with…but with… ，和……无关，而和……有关<br>occur in cases ，还有种情况是……<br>there is room for doubt… ，在……方面存有疑虑 。<br>far from 远离；远非；完全不<br>puff out one’s chest  挺起胸膛<br>to the best of my belief 据我所知<br>on account of sth 由于，因为..<br>out of ordinary 不寻常<br>a roof over one’s head 住处，栖身之处</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.「rise」：在文中指“站起来，起立”，常见意思为“上升，增长”。&lt;/p&gt;
&lt;p&gt;原句：The gentleman half rose from his chair to greet me.  &lt;/p&gt;
&lt;p&gt;2.「nature」：在文中的意思为“本质、性质”，常见意思
      
    
    </summary>
    
      <category term="感悟" scheme="http://sdhmdhr123.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="英语" scheme="http://sdhmdhr123.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
</feed>
