<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aston</title>
  
  <subtitle>记录学习的技能以及平时的感悟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sdhmdhr123.github.io/"/>
  <updated>2018-05-09T15:08:14.391Z</updated>
  <id>http://sdhmdhr123.github.io/</id>
  
  <author>
    <name>Aston</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>归一化和标准化以及正则化</title>
    <link href="http://sdhmdhr123.github.io/2018/05/09/%E5%BD%92%E4%B8%80%E5%8C%96%E5%92%8C%E6%A0%87%E5%87%86%E5%8C%96/"/>
    <id>http://sdhmdhr123.github.io/2018/05/09/归一化和标准化/</id>
    <published>2018-05-09T07:35:12.000Z</published>
    <updated>2018-05-09T15:08:14.391Z</updated>
    
    <content type="html"><![CDATA[<p>​    很多的时候我发现很多人和我一样我对机器学习的基本概念一知半解,比如我经常会听到归一化及标准化,傻傻分不清楚。最近看了一篇文章清楚的阐述了归一化和标准化的定义、适用场景、物理意义及使用意义。经过原作者授权以后,我想进行转发并加上我的一些理解,和更多的人一起学习进步。</p><p>在机器学习和数据挖掘中,经常会听到两个名词:归一化(Normalization)与标准化(Standardization)。它们具体是什么?带来什么益处?具体怎么用?本文来具体讨论这些问题。</p><p>一、是什么</p><p>\1. 归一化</p><p>常用的方法是通过对原始数据进行线性变换把数据映射到[0,1]之间,变换函数为:</p><p> <img src="/2018/05/09/归一化和标准化/5c5e6e29d62f55de35ff2d09a309cdc4.jpg" alt="归一化和标准化的一些理解_Python"></p><p>其中min是样本中最小值,max是样本中最大值,注意在数据流场景下最大值与最小值是变化的。另外,最大值与最小值非常容易受异常点影响,所以这种方法鲁棒性较差,只适合传统精确小数据场景。</p><p>\2. 标准化</p><p>常用的方法是z-score标准化,经过处理后的数据均值为0,标准差为1,处理方法是:</p><p> <img src="/2018/05/09/归一化和标准化/13f1e840dfcc48357436562012546840.jpg" alt="归一化和标准化的一些理解_Python"></p><p>其中μ是样本的均值,σ是样本的标准差,它们可以通过现有样本进行估计。在已有样本足够多的情况下比较稳定,适合现代嘈杂大数据场景。</p><p>二、带来什么</p><p>归一化的依据非常简单,不同变量往往量纲不同,归一化可以消除量纲对最终结果的影响,使不同变量具有可比性。比如两个人体重差10KG,身高差0.02M,在衡量两个人的差别时体重的差距会把身高的差距完全掩盖,归一化之后就不会有这样的问题。</p><p>标准化的原理比较复杂,它表示的是原始值与均值之间差多少个标准差,是一个相对值,所以也有去除量纲的功效。同时,它还带来两个附加的好处:均值为0,标准差为1。</p><p>均值为0有什么好处呢?它可以使数据以0为中心左右分布(这不是废话嘛),而数据以0为中心左右分布会带来很多便利。比如在去中心化的数据上做SVD分解等价于在原始数据上做PCA;机器学习中很多函数如Sigmoid、Tanh、Softmax等都以0为中心左右分布(不一定对称)。</p><p>标准差为1有什么好处呢?这个更复杂一些。对于xi与xi′两点间距离,往往表示为</p><p> <img src="/2018/05/09/归一化和标准化/e86be3c73d62e2b40a630b54016298ef.jpg" alt="归一化和标准化的一些理解_Python"></p><p>其中dj(xij,xi′j)是属性jj两个点之间的距离,wj是该属性间距离在总距离中的权重,注意设wj=1,∀jwj=1,∀j并不能实现每个属性对最后的结果贡献度相同。对于给定的数据集,所有点对间距离的平均值是个定值,即</p><p> <img src="/2018/05/09/归一化和标准化/1968a23ebc9887677a29b20c061e32ac.jpg" alt="归一化和标准化的一些理解_Python">    </p><p>是个常数,其中</p><p> <img src="/2018/05/09/归一化和标准化/e11b206babcca3a775777bcb67bc0222.jpg" alt="归一化和标准化的一些理解_Python"></p><p>可见第jj个变量对最终整体平均距离的影响是wj⋅¯dj,所以设wj∼1/¯dj可以使所有属性对全数据集平均距离的贡献相同。现在设djdj为欧式距离(或称为二范数)的平方,它是最常用的距离衡量方法之一,则有</p><p><img src="/2018/05/09/归一化和标准化/edc8f93b09da354065429a7b3917e76a.jpg" alt="归一化和标准化的一些理解_Python"> </p><p>其中varjvarj是Var(Xj)Var(Xj)的样本估计,也就是说每个变量的重要程度正比于这个变量在这个数据集上的方差。如果我们让每一维变量的标准差都为1(即方差都为1),每维变量在计算距离的时候重要程度相同。</p><p>三、怎么用</p><p>在涉及到计算点与点之间的距离时,使用归一化或标准化都会对最后的结果有所提升,甚至会有质的区别。那在归一化与标准化之间应该如何选择呢?根据上一节我们看到,如果把所有维度的变量一视同仁,在最后计算距离中发挥相同的作用应该选择标准化,如果想保留原始数据中由标准差所反映的潜在权重关系应该选择归一化。另外,标准化更适合现代嘈杂大数据场景。</p><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>我尽量用通俗一点的话来解答一下楼主的问题，</p><p>r(<strong>d</strong>)可以理解为有d的参数进行约束，或者 <strong>D</strong> 向量有d个维度。<br>咱们将楼主的给的凸优化结构细化一点，别搞得那么抽象，不好解释；</p><p><img src="https://www.zhihu.com/equation?tex=min%5Cleft%5C%7B++%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%5E%7BN%7D%7B%28y_%7Bi%7D+-+f%28x_%7Bi%7D+%29%29%5E%7B2%7D++%2B+r%28d%29%7D+++%5Cright%5C%7D+" alt="min\left\{  \frac{1}{N}\sum_{i=1}^{N}{(y_{i} - f(x_{i} ))^{2}  + r(d)}   \right\} "> , 其中，<br>咱们可以令:  f(<img src="/2018/05/09/归一化和标准化/equation.svg" alt="x_{i} ">) = <img src="/2018/05/09/归一化和标准化/equation.svg" alt="w_{0}x_{0} + w_{1} x_{1} + w_{2}x_{2} + w_{3}x_{3} + ..... + w_{n}x_{n}">.</p><p>ok，这个先介绍到这里，至于f(x)为什么用多项式的方式去模拟？相信也是很多人的疑问，很简单，大家看看高等数学当中的泰勒展开式就行了，任何函数都可以用多项式的方式去趋近，<img src="/2018/05/09/归一化和标准化/equation.svg" alt="e^{x} ,">log x,lnx,<img src="/2018/05/09/归一化和标准化/equation-1525853997318.svg" alt="\frac{1}{x} ">等等都可以去趋近，而不同的函数曲线其实就是这些基础函数的组合，理所当然也可以用多项式去趋近，好了，这个就先解释到这里了。</p><p>接下来咱们看一下拟合的基础概念。<br>首先，用一个例子来理解什么是过拟合，假设我们要根据特征分类{男人X，女人O}。<br>请看下面三幅图，x1、x2、x3；<img src="/2018/05/09/归一化和标准化/v2-d88d37f41b60d2eb3cbce6d9771b2eed_hd.jpg" alt="img"></p><p>好了，总结一下三幅图：<br>x1我们称之为【欠拟合】<br>x2我们称之为【分类正拟合】，随便取的名字，反正就是容错情况下刚好的意思。<br>x3我们称之为【过拟合】，这种情况是我们不希望出现的状况，为什么呢？很简单，它的分类只是适合于自己这个测试用例，对需要分类的真实样本而言，实用性可想而知的低。</p><p>恩，知道了过拟合是怎么回事之后，我们来看一下如何去规避这种风险。先不管什么书上说的、老师讲的、经验之说之类的文言文。咱们就站在第一次去接触这种分类模型的角度去看待这个问题，发散一下思维，我们应该如何去防止过拟合？<br><strong>显而易见</strong>，我们应该从【过拟合】出现的特征去判别，才能规避吧？<br><strong>显而易见</strong>，我们应该、而且只能去看【过拟合】的f(x)形式吧？<br><strong>显而易见</strong>，我们从【过拟合】的图形可以看出f(x)的涉及到的特征项一定很多吧，即<img src="/2018/05/09/归一化和标准化/equation-1525853997319.svg" alt="x_{0},x_{1},x_{2},x_{3}....x_{N} ">等等很多吧？<br><strong>显而易见</strong>，N很大的时候，</p><p><img src="https://www.zhihu.com/equation?tex=w_%7B0%7D+%2Cw_%7B1%7D+%2Cw_%7B2%7D+%2Cw_%7B3%7D+%2C...w_%7BN%7D+" alt="w_{0} ,w_{1} ,w_{2} ,w_{3} ,...w_{N} ">是等数量增长的吧？<br><strong>显而易见</strong>，w系数都是学习来的吧？</p><p>So，现在知道这些信息之后，如何去防止过拟合，我们首先想到的就是控制N的数量吧，即让N最小化吧，而让N最小化，其实就是让<strong>W</strong>向量中项的个数最小化吧？<br>其中，<strong>W</strong>=(<img src="https://www.zhihu.com/equation?tex=w_%7B0%7D+%2Cw_%7B1%7D+%2Cw_%7B2%7D+%2Cw_%7B3%7D+%2C...w_%7BN%7D+" alt="w_{0} ,w_{1} ,w_{2} ,w_{3} ,...w_{N} ">)</p><p>PS: 可能有人会问，为什么是考虑<strong>W</strong>，而不是考虑<strong>X</strong>?很简单，你不知道下一个样本想x输入的是什么，所以你怎么知道如何去考虑x呢？相对而言，在下一次输入<img src="https://www.zhihu.com/equation?tex=x%5E%7B%28k%29%7D+" alt="x^{(k)} ">,即第k个样本之前，我们已经根据<img src="https://www.zhihu.com/equation?tex=x%5E%7B%281%29%7D+%2Cx%5E%7B%282%29%7D+%2C....x%5E%7B%28k-1%29%7D+" alt="x^{(1)} ,x^{(2)} ,....x^{(k-1)} ">次测试样本的输入，计算(学习)出了<strong>W.</strong>就是这么个道理，很简单。</p><p>ok,any way.回到上面的思维导图的位置，我们再来思考，如何求解“让<strong>W</strong>向量中项的个数最小化”这个问题，学过数学的人是不是看到这个问题有点感觉？对，没错，这就是0范数的概念！什么是范数，我在这里只是给出个0-2范数定义，不做深究，以后有时间在给大家写点文章去分析范数的有趣玩法；<br>0范数，向量中非零元素的个数。<br>1范数，为绝对值之和。<br>2范数，就是通常意义上的模。</p><p>PS，貌似有人又会问，上面不是说求解“让<strong>W</strong>向量中项的个数最小化”吗？怎么与0范数的定义有点不一样，一句话，向量中0元素，对应的x样本中的项我们是不需要考虑的，可以砍掉。因为<img src="/2018/05/09/归一化和标准化/equation.svg" alt="0 x_{i} ">没有啥意义，说明<img src="/2018/05/09/归一化和标准化/equation.svg" alt="x_{i} ">项没有任何权重。so，一个意思啦。</p><p>ok，现在来回答楼主的问题，r(d) = “让<strong>W</strong>向量中项的个数最小化”  = <img src="/2018/05/09/归一化和标准化/equation.svg" alt="\left| W \right| _{0} "></p><p><strong>所以为了防止过拟合，咱们除了需要前面的相加项最小，即楼主公式当中的<img src="https://www.zhihu.com/equation?tex=R_%7Bemp%7D%28f%29+" alt="R_{emp}(equation.svg) "> = <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B2%7DW%5E%7BT%7DW%2B%5Csum_%7Bi%7D%5E%7B%7D%7Bl%28y_%7Bi%7D%2Cf%28x_%7Bi%7D+%29+%29%7D+++" alt="\frac{1}{2}W^{T}W+\sum_{i}^{}{l(equation-1525853997317.svg )}   "> 最小，我们还需要让r(d)=<img src="https://www.zhihu.com/equation?tex=%5Cleft%7C+W+%5Cright%7C+_%7B0%7D+" alt="\left| W \right| _{0} ">最小，所以，为了同时满足两项都最小化，咱们可以求解让<img src="https://www.zhihu.com/equation?tex=R_%7Bemp%7D%28f%29+" alt="R_{emp}(equation.svg) ">和r(d)之和最小，这样不就同时满足两者了吗？如果r(d) 过大，<img src="https://www.zhihu.com/equation?tex=R_%7Bemp%7D%28f%29+" alt="R_{emp}(equation.svg) ">再小也没用；相反r(d)再小，<img src="https://www.zhihu.com/equation?tex=R_%7Bemp%7D%28f%29+" alt="R_{emp}(equation.svg) ">太大也失去了问题的意义。说到这里我觉得楼主的问题我已经回答了，那就是为什么需要有个r(d)项，为什么r(d)能够防止过拟合原因了。</strong><br>根据《男人帮》电影大结局的剧情：本来故事已经完成了，为了让大家不至于厌恶课本的正规理论，我们在加上一集内容，用以表达我对机器学习出书者的尊重；</p><p>书本中，或者很多机器学习的资料中，为了让全球的机器学习人员有个通用的术语，同时让大家便于死记硬本，给我上一段黑体字的部分的内容加上了一坨定义，例如：<br>我们管<img src="https://www.zhihu.com/equation?tex=R_%7Bemp%7D%28f%29+" alt="R_{emp}(f) ">叫做<strong>经验风险</strong>，管上面我们思维导图的过程叫做<strong>正则化</strong>，所以顺其自然的管r(d)叫做<strong>正则化项</strong>，然后管<img src="https://www.zhihu.com/equation?tex=R_%7Bemp%7D%28f%29+" alt="R_{emp}(f) ">+r(d) 叫做<strong>结构风险</strong>，所以顺其自然的<strong>正则化</strong>就是我们将<strong>结构风险</strong>最小化的过程，它们是等价的。<br>By the way，各位计算机界的叔叔、阿姨、伯伯、婶婶，经过不懈的努力，发现了这个公式很多有意思的地方，它们发现0范数比较恶心，很难求，求解的难度是个NP完全问题。然后很多脑袋瓜子聪明的叔叔、阿姨、伯伯、婶婶就想啊，0范数难求，咱们就求1范数呗，然后就研究出了下面的等式：</p><p><img src="/2018/05/09/归一化和标准化/v2-6d969121bc4c9b71a9887276194cc4ac_hd.jpg" alt="img"></p><p> L2范数是指向量各元素的平方和然后求平方根。我们让L2范数的正则项||W||2最小，可以使得W的每个元素都很小，都接近于0，但与L1范数不同，它不会让它等于0，而是接近于0，这里是有很大的区别的哦；所以大家比起1范数，更钟爱2范数。</p><p><img src="/2018/05/09/归一化和标准化/v2-795133444a6c7b501683a5805a68b81b_hd.jpg" alt="img"></p><p>区别：</p><p>1:<br>L1不可导，L2可导<br>2:<br>L1有稀疏性，L2当更新到权重很小的时候就不再更新这个权重了，不具有稀疏性</p><p>L2是平方和再开方 L1是绝对值之和 L0是非零元素个数</p><p>关于为什么L1能导致稀疏性的论证参考 trevor hstie. robert tibsirani jerome friedman  <em>the elements of statistical learnig</em> 中的3.4节</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    很多的时候我发现很多人和我一样我对机器学习的基本概念一知半解,比如我经常会听到归一化及标准化,傻傻分不清楚。最近看了一篇文章清楚的阐述了归一化和标准化的定义、适用场景、物理意义及使用意义。经过原作者授权以后,我想进行转发并加上我的一些理解,和更多的人一起学习进步。
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Perceptron and Adaptive Linear Neuron</title>
    <link href="http://sdhmdhr123.github.io/2018/05/07/perceptron/"/>
    <id>http://sdhmdhr123.github.io/2018/05/07/perceptron/</id>
    <published>2018-05-07T01:36:57.000Z</published>
    <updated>2018-05-07T09:37:03.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>感知机的英文是perceptron, as the name suggests,意思就是认知感觉的元件，是最初由神经元模型发展而来。神经元的工作机制被McCullock and Pitts描述为一个具备二进制输出的逻辑门。在Mccullock-pitts之后,Frank rossenblatt 提出了第一个感知器学习法则。在此规则中，rossenblatt提出了一个自学习算法，这个算法可以自动更新权重参数，此系数与输入的乘积决定了是否激活神经元。</p><p>简单来讲，感知机可以看做是神经网络的或者说是SVM的组成元件，是一个“神经元”。最初感知机直接使用的单位跃阶函数即分段函数。能执行的功能只有简单的线性分类（单个），不能处理多分类等复杂问题。</p><p><img src="/2018/05/07/perceptron/1525679665125.png" alt="1525679665125"></p><p>权重的更新规则</p><p> w = w + △w</p><p>△w是 学习速率，预测类表与实际类标，输出x的乘积</p><p>所以每迭代一次，权重更新一次，但是样本是一个一个输进去的。</p><p>感知机需要设置一个阈值，以防止当出现线性不可分问题而出现的无限循环。</p><p>感知机的实现</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Perceptron</span>(<span class="title">object</span>):</span></span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">    parameters:</span></span><br><span class="line"><span class="string">    ---------------------------</span></span><br><span class="line"><span class="string">    eta:float</span></span><br><span class="line"><span class="string">    learning rate between 0.1 and 1.0</span></span><br><span class="line"><span class="string">    n_iter : int</span></span><br><span class="line"><span class="string">    passes over the training dataset</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    attributes:</span></span><br><span class="line"><span class="string">    ---------------------------</span></span><br><span class="line"><span class="string">    w_ : 1d-array</span></span><br><span class="line"><span class="string">    weights after fitting.</span></span><br><span class="line"><span class="string">    errors_: list</span></span><br><span class="line"><span class="string">    number of misclassifications in every epoch</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,eta = <span class="number">0</span>.<span class="number">01</span>,n_iter = <span class="number">10</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.eta= eta</span><br><span class="line">        <span class="keyword">self</span>.n_iter = n_iter</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(<span class="keyword">self</span>,X,y)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">        parameters:</span></span><br><span class="line"><span class="string">        -------------------------</span></span><br><span class="line"><span class="string">        X: &#123;array-like&#125;,shape =&#123;n_samples,n_features&#125;</span></span><br><span class="line"><span class="string">            training vectors, where n_samples is the</span></span><br><span class="line"><span class="string">            number of samples and n_features is the </span></span><br><span class="line"><span class="string">            number of features</span></span><br><span class="line"><span class="string">        Y: array-like,shape=&#123;n_samples&#125;</span></span><br><span class="line"><span class="string">            target values</span></span><br><span class="line"><span class="string">        '</span><span class="string">''</span></span><br><span class="line">        <span class="keyword">self</span>.w<span class="number">_</span> = np.zeros(<span class="number">1</span> + X.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">self</span>.errors<span class="number">_</span> = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="keyword">self</span>.n_iter)<span class="symbol">:</span></span><br><span class="line">            errors = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> xi,target <span class="keyword">in</span> zip(X,y)<span class="symbol">:</span></span><br><span class="line">                update= <span class="keyword">self</span>.eta * (target - <span class="keyword">self</span>.predict(xi))</span><br><span class="line">                <span class="keyword">self</span>.w<span class="number">_</span>[<span class="number">1</span><span class="symbol">:</span>] += update *xi</span><br><span class="line">                <span class="keyword">self</span>.w<span class="number">_</span>[<span class="number">0</span><span class="symbol">:</span>] += update</span><br><span class="line">                errors += int(update != <span class="number">0</span>.<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">self</span>.errors<span class="number">_</span>.append(errors)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">net_input</span><span class="params">(<span class="keyword">self</span>,X)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">"calculate net input "</span></span><br><span class="line">        <span class="keyword">return</span> np.dot(X,<span class="keyword">self</span>.w<span class="number">_</span>[<span class="number">1</span><span class="symbol">:</span>] + <span class="keyword">self</span>.w<span class="number">_</span>[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(<span class="keyword">self</span>,X)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="string">"return class laber after unit step"</span></span><br><span class="line">        <span class="keyword">return</span> np.where(<span class="keyword">self</span>.net_input(X)&gt;= <span class="number">0</span>.<span class="number">0</span> , <span class="number">1</span> , -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>就是画一条直线进行分类，只能分成两类,是或否。</p><h2 id="adaline"><a href="#adaline" class="headerlink" title="adaline"></a>adaline</h2><p>自适应线性神经元，</p><p>检验是否掌握了刚学过的知识的最有效方法就是能不能把它表达出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;感知机&quot;&gt;&lt;a href=&quot;#感知机&quot; class=&quot;headerlink&quot; title=&quot;感知机&quot;&gt;&lt;/a&gt;感知机&lt;/h2&gt;&lt;p&gt;感知机的英文是perceptron, as the name suggests,意思就是认知感觉的元件，是最初由神经元模型发展而来。
      
    
    </summary>
    
      <category term="学习" scheme="http://sdhmdhr123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>科研（二）</title>
    <link href="http://sdhmdhr123.github.io/2018/04/20/%E7%A7%91%E7%A0%94%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://sdhmdhr123.github.io/2018/04/20/科研（二）/</id>
    <published>2018-04-20T08:19:05.000Z</published>
    <updated>2018-05-07T07:49:12.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>physionet2018challenge最近更新了一个比赛所需要提交的模板，用于统一的效果评估。</p><p>包含以下几个文件</p><p><img src="/2018/04/20/科研（二）/Users/Aston/Desktop/1524213029682.png" alt="1524213029682"></p><p>我大概看了一下，很有用省去了一些可能需要我自己写的读写之类的内容，我们接下来就看一下吧！</p><p>AUTHORS.txt : 是一个空白文件，其中需要填写关于参赛者的信息（也就是你自己）。</p><p>dependencies.txt :内容如下,写了运行你的程序前需要安装的包，也就是我们程序的运行环境信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> file: dependencies.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This file lists additional Debian packages that must be installed</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> prior to running your entry<span class="string">'s '</span>setup.sh<span class="string">' and '</span>next.sh<span class="string">' scripts.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Each package must be on a separate line.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Likely to be useful for most challenge entries</span></span></span><br><span class="line"></span><br><span class="line">python3-numpy</span><br><span class="line">python3-scipy</span><br><span class="line">python3-h5py</span><br><span class="line">libopenblas-base</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Additional libraries used by this example</span></span></span><br><span class="line"></span><br><span class="line">python3-sklearn</span><br><span class="line">python3-pandas</span><br><span class="line">python3-matplotlib</span><br><span class="line">python3-tk</span><br></pre></td></tr></table></figure><p>LICENSE.txt :这个是软件安装协议，就是我们平时安装软件完全不看直接点同意的那个东西，由于我也不参赛，也不打算发布软件啥的，所以我也没仔细看，基本上所有的这种东西都差不多。</p><p>next.sh、setup.sh: 这是两个shell脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file: next.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This bash script analyzes the record named <span class="keyword">in</span> its <span class="built_in">command</span>-line</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> argument (<span class="variable">$1</span>), and writes per-sample classification to the file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"<span class="variable">$1</span>.vec"</span>.  This script is run once <span class="keyword">for</span> each record <span class="keyword">in</span> the Challenge</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">test</span> <span class="built_in">set</span>.  The input record (<span class="variable">$1</span>.hea and <span class="variable">$1</span>.mat) will be located <span class="keyword">in</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the current working directory.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The output file must be a plain text file, with one line <span class="keyword">for</span> each</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sample of the record.  Each line must be a number between 0 and 1,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> indicating the probability that an arousal is occurring at that</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> instant.  For an (unrealistic) example, <span class="keyword">if</span> an arousal appears to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> begin 15 milliseconds after the start of the record, the <span class="variable">$RECORD</span>.vec</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> file might contain:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0.000</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0.002</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0.048</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0.955</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1.000</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0.946</span></span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line">RECORD=$1</span><br><span class="line"></span><br><span class="line">./run_my_classifier.py "$RECORD"</span><br></pre></td></tr></table></figure><p>意思就是这个bash脚本是分析记录,写出每一个样本的分类到$1.vec。每个挑战赛的测试样本跑一次这个脚本。输入的文件.hea 和.mat应在当前目录下。</p><p>输出文件是纯文本文件，每行都是一个样本的记录，且记录是在0-1直接的数字。代表唤醒概率，如果唤醒发生在开始的15毫秒，$record.vec可能包括那几个例子。</p><p>set -e 作用是告诉bash如果执行结果不是True就退出，好处是防止错误滚雪球。这个应该出现在每一个bash脚本之前。但后期升级脚本可能存在隐患。set -o pipefail  pipefail表示在管道连接的命令序列中，只要有任何一个命令返回非0值，则整个管道返回非0值，即使最后一个命令返回0. emm这个主要是是说运行管道程序时一般是返回最后一个的结果，这个是返回管道前的结果。我感觉没什么用，他也没用管道。。</p><p>setup是在你分类器运行前安汉族昂需要安装的包，这个程序是第一个被执行的程序。</p><p>physionetchallenge2018_lib.py: 这是一个读数据名称的文档，能给我们省不少事，一共六个函数。</p><p>get_files,得到四类文件的名字，制作成一个dataframe，返回两个分别是test一个是train的路径名称的dataframe。.hea arousal.mat .mat都存在表里了如果要用可以调，没有存 arousal，这个是个注释文件，不知道主要是干啥的，以后再考虑。</p><p>三个import函数就是分别把 信号文件名.mat arousal.mat都输进来</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_subject_dat<span class="built_in">a_test</span> 返回了不带标签的信号</span><br><span class="line">get_subject_data 返回了带标注的信号，即多一个维度，在对应行多一个数据</span><br></pre></td></tr></table></figure><hr><p>train_classifier: 训练模型 init process_record finish</p><p>run_my_classifier: 利用训练好的模型对测试集进行预测。run_my_classifier classify_record</p><p>prepare_entry.py ：生成提交比赛格式。</p><p>包含四个函数train、score_train_set、evaluete_test_set、package_entry 这个函数引用了其他三个Python文件</p><hr><p>除了比赛给的这个读取数据方式（利用scipy处理mat文件然后逐步自行处理），还可以利用physionet的wfdb读信号。</p><p>wfdb是physionet出品的医学信号处理的工具，可作为软件使用，也为多种语言提供了接口，其中python版是简化版的软件，提供了信号处理的核心功能。包括了可视化，信号处理，标注，预测等功能。</p><p>我用一组数据试了一下，如下图</p><p><img src="/2018/04/20/科研（二）/Users/Aston/Desktop/Figure_2.png" alt="Figure_2"></p><hr><p>综上，physionet提供的便利很大，我们只要往里填一个算法就够，感觉工作量一下变得巨小，而且同时有这么多人在做，感觉有点虚，用这个毕业感觉不太行，得想想办法把它往复杂化做。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据处理&quot;&gt;&lt;a href=&quot;#数据处理&quot; class=&quot;headerlink&quot; title=&quot;数据处理&quot;&gt;&lt;/a&gt;数据处理&lt;/h2&gt;&lt;p&gt;physionet2018challenge最近更新了一个比赛所需要提交的模板，用于统一的效果评估。&lt;/p&gt;
&lt;p&gt;包含以下
      
    
    </summary>
    
      <category term="科研" scheme="http://sdhmdhr123.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Os_walk使用</title>
    <link href="http://sdhmdhr123.github.io/2018/04/20/os-walk/"/>
    <id>http://sdhmdhr123.github.io/2018/04/20/os-walk/</id>
    <published>2018-04-20T08:16:25.000Z</published>
    <updated>2018-04-20T08:17:18.114Z</updated>
    
    <content type="html"><![CDATA[<p>python中os.walk是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。</p><p>1.载入<br>要使用os.walk,首先要载入该函数</p><p>可以使用以下两种方法</p><ul><li>import os</li><li>from os import walk</li></ul><p>2.使用</p><p>os.walk的函数声明为:</p><p>walk(top, topdown=True, onerror=None, followlinks=False)</p><p>参数</p><ul><li>top 是你所要便利的目录的地址</li><li>topdown 为真，则优先遍历top目录，否则优先遍历top的子目录(默认为开启)</li><li>onerror 需要一个 callable 对象，当walk需要异常时，会调用</li><li>followlinks 如果为真，则会遍历目录下的快捷方式(linux 下是 symbolic link)实际所指的目录(默认关闭)</li></ul><p>os.walk 的返回值是一个生成器(generator),也就是说我们需要不断的遍历它，来获得所有的内容。</p><p>每次遍历的对象都是返回的是一个三元组(root,dirs,files)</p><ul><li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li><li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)</li><li>files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</li></ul><p>如果topdown 参数为真，walk 会遍历top文件夹，与top文件夹中每一个子目录。</p><p>举个例子</p><p>如果我们有如下的文件结构:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> -&gt;   <span class="selector-tag">b</span>   -&gt;   <span class="number">1</span><span class="selector-class">.txt</span>,  <span class="number">2</span>.txt</span><br><span class="line">       c   -&gt;   <span class="number">3</span>.txt</span><br><span class="line">       d   -&gt;   </span><br><span class="line">     <span class="number">4</span>.txt</span><br><span class="line">     <span class="number">5</span>.txt</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (root, dirs, <span class="built_in">files</span>) <span class="keyword">in</span> os.walk(<span class="string">'a'</span>):</span><br><span class="line">    <span class="comment">#第一次运行时，当前遍历目录为 a</span></span><br><span class="line">    所以 root == <span class="string">'a'</span></span><br><span class="line">         dirs == [ <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line">         <span class="built_in">files</span> == [ <span class="string">'4.txt'</span>, <span class="string">'5.txt'</span>]</span><br><span class="line">    </span><br><span class="line">    。。。</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接着遍历 dirs 中的每一个目录</span></span><br><span class="line">    b:  root  = <span class="string">'a\\b'</span></span><br><span class="line">        dirs  = []</span><br><span class="line">        <span class="built_in">files</span> = [ <span class="string">'1.txt'</span>, <span class="string">'2.txt'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dirs为空，返回</span></span><br><span class="line">    <span class="comment"># 遍历c</span></span><br><span class="line">    c:  root  = <span class="string">'a\\c'</span></span><br><span class="line">        dirs  = []</span><br><span class="line">        <span class="built_in">files</span> = [ <span class="string">'3.txt'</span> ]</span><br><span class="line">    </span><br><span class="line">    PS : 如果想获取文件的全路径，只需要 </span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">files</span>:</span><br><span class="line">        path = os.path.join(root,f)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历d</span></span><br><span class="line">    d:  root  = <span class="string">'a\\b'</span></span><br><span class="line">        dirs  = []</span><br><span class="line">        <span class="built_in">files</span> = []</span><br><span class="line"></span><br><span class="line">    遍历完毕，退出循环</span><br></pre></td></tr></table></figure><p>3.简单的例子</p><p>保持目录 a 的目录结构，在 b 中创建对应的文件夹,并把a中所有的文件加上后缀 _bak</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">Root = <span class="string">'a'</span></span><br><span class="line">Dest = <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (root, dirs, files) <span class="keyword">in</span> os.walk(Root):<span class="type"></span></span><br><span class="line"><span class="type">    new_root </span>= root.replace(Root, Dest, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> not os.path.exists(<span class="keyword">new</span><span class="type">_root</span>):<span class="type"></span></span><br><span class="line"><span class="type">        os</span>.mkdir(<span class="keyword">new</span><span class="type">_root</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> dirs:<span class="type"></span></span><br><span class="line"><span class="type">        d </span>= os.path.join(<span class="keyword">new</span><span class="type">_root</span>, d)</span><br><span class="line">        <span class="keyword">if</span> not os.path.exists(d):<span class="type"></span></span><br><span class="line"><span class="type">            os</span>.mkdir(d)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> files:<span class="type"></span></span><br><span class="line"><span class="type">        </span># 把文件名分解为 文件名.扩展名</span><br><span class="line">        <span class="meta"># 在这里可以添加一个 filter，过滤掉不想复制的文件类型，或者文件名</span></span><br><span class="line">        (shotname, extension) = os.path.splitext(f)</span><br><span class="line">        <span class="meta"># 原文件的路径</span></span><br><span class="line">        old_path = os.path.join(root, f)</span><br><span class="line">        <span class="keyword">new</span><span class="type">_name</span> = shotname + <span class="string">'_bak'</span> + extension</span><br><span class="line">        <span class="meta"># 新文件的路径</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">_path</span> = os.path.join(<span class="keyword">new</span><span class="type">_root</span>, <span class="keyword">new</span><span class="type">_name</span>)</span><br><span class="line">        <span class="keyword">try</span>:<span class="type"></span></span><br><span class="line"><span class="type">            </span># 复制文件</span><br><span class="line">            open(<span class="keyword">new</span><span class="type">_path</span>, <span class="string">'wb'</span>).write(open(old_path, <span class="string">'rb'</span>).read())</span><br><span class="line">        except IOError as e:<span class="type"></span></span><br><span class="line"><span class="type">            print</span>(e)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python中os.walk是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。&lt;/p&gt;
&lt;p&gt;1.载入&lt;br&gt;要使用os.walk,首先要载入该函数&lt;/p&gt;
&lt;p&gt;可以使用以下两种方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;import os&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Github+hexo插入本地图片方法</title>
    <link href="http://sdhmdhr123.github.io/2018/04/16/github-hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95/"/>
    <id>http://sdhmdhr123.github.io/2018/04/16/github-hexo插入图片方法/</id>
    <published>2018-04-16T13:11:31.000Z</published>
    <updated>2018-04-18T07:56:40.677Z</updated>
    
    <content type="html"><![CDATA[<p>用markdown+hexo传到github这一套写博客的话感觉挺帅的，但是我发现有一个巨大的坑，就是在使用本地图片时，传到github就没法用了。</p><p>搜了半天，发现最简便的方法就是把_config.yml的 create_asset_folder 改成true，然后安装一个插件（我看了一眼我那个代码好像并没有安装成功，反正能用），这样在建立文章时就会随之产生一个文件夹，你把图片放进去，然后在写文章的时候直接写<code>[example](filename/test.png)</code>就可以了。</p><p>但是我感觉这样还是很麻烦，这里有一个markdown编辑神器，typora，可以拖拽插入图片，如果是网络上的图片就直接插入进去了，但如果是本地的，typora有三个选项，一个是生成<code>./pic.png</code> 、<code>asset/pc.png</code>、<code>filename.asset/pic.png</code>。</p><p>由于我发现你只要把图片放在那个同名文件夹内，传到github里面你的文章和图片就会在一个文件夹里了，所以你只要在用typora时选第一个<code>./pic.png</code> 然后把这些图片复制到同名文件夹中就可以了。</p><p>如果你不需要上传到github，你可以利用typora导出pdf格式，非常好用！</p><hr><p>ps：另外，有一个困惑我很久的事情就是我用相对路径的图片统统不成功，我之前一直是传到github然后复制那个地址贴在文章里了，，后来我发现了。。只有config.yml里吧那个relative_link改成true就成了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用markdown+hexo传到github这一套写博客的话感觉挺帅的，但是我发现有一个巨大的坑，就是在使用本地图片时，传到github就没法用了。&lt;/p&gt;
&lt;p&gt;搜了半天，发现最简便的方法就是把_config.yml的 create_asset_folder 改成true
      
    
    </summary>
    
      <category term="学习" scheme="http://sdhmdhr123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>科研（一）</title>
    <link href="http://sdhmdhr123.github.io/2018/04/16/%E7%A7%91%E7%A0%94%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://sdhmdhr123.github.io/2018/04/16/科研（一）/</id>
    <published>2018-04-16T12:47:29.000Z</published>
    <updated>2018-05-07T07:49:01.029Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="数据信息"><a href="#数据信息" class="headerlink" title="数据信息"></a>数据信息</h1><p><a href="https://www.physionet.org/challenge/2018/" target="_blank" rel="noopener">physionet</a></p><p>2018年PhysioNet /计算机心脏病学挑战的数据由麻省总医院（MGH）计算临床神经生理学实验室（CCNL）和临床数据动画实验室（CDAC）提供。 该数据集包括在MGH睡眠实验室监测的1,985个受试者，用于诊断睡眠障碍。 数据平衡地分为训练集（n = 994）和测试集（n = 989）。 收集的患者的临床特征和结果列于下表1中。</p><p><strong>Table 1:</strong> <em>Clinical characteristics of the dataset, and those of the training, and testing set.</em></p><table><thead><tr><th>Clinical Feature</th><th>Total(n = 1893)</th><th>Train(n = 994)</th><th>Test(n = 989)</th></tr></thead><tbody><tr><td>Age</td><td>55(+/-14.4)</td><td>55(+/-14.3)</td><td>55(+/-14.4)</td></tr><tr><td>Body Mass Index</td><td>33(+/-7.6)</td><td>33(+/-7.8)</td><td>33(+/-7.5)</td></tr><tr><td>Epworth Sleepiness Scale[1]</td><td>8.6(+/-5.3)</td><td>8.5(+/-5.3)</td><td>8.7(+/-5.3)</td></tr><tr><td>Gender (% Male)</td><td>65</td><td>67</td><td>63</td></tr><tr><td><strong>Drug Use (%)</strong></td><td></td><td></td><td></td></tr><tr><td>Antidepressant抗抑郁</td><td>26.1</td><td>25.7</td><td>26.5</td></tr><tr><td>Antihistamine 抗组胺</td><td>4.8</td><td>4.8</td><td>4.8</td></tr><tr><td>Benzodiazepine 镇静类药物</td><td>16.1</td><td>16.9</td><td>15.4</td></tr><tr><td>Diabetic 糖尿病药物</td><td>11.7</td><td>11.9</td><td>11.5</td></tr><tr><td>Herbal 草本药物</td><td>4.2</td><td>4.3</td><td>4.0</td></tr><tr><td>Hypertension 高血压类</td><td>40.9</td><td>41.0</td><td>40.6</td></tr><tr><td>Neuroleptic 安定类药物</td><td>4.2</td><td>4.5</td><td>3.8</td></tr><tr><td>Opiate 麻醉类药物</td><td>7.4</td><td>8.1</td><td>6.7</td></tr><tr><td>Neuroactive 神经兴奋类</td><td>19.1</td><td>20.8</td><td>17.5</td></tr><tr><td>Sleep aids 助睡眠类</td><td>28.3</td><td>29.0</td><td>27.8</td></tr><tr><td>Stimulant 兴奋剂</td><td>4.7</td><td>3.9</td><td>5.5</td></tr><tr><td><strong>Reason For Visit (%)</strong></td><td></td><td></td><td></td></tr><tr><td>Diagnostic (%) 就诊</td><td>41.8</td><td>41.16</td><td>42.47</td></tr><tr><td>Split Night CPAP (%) [2]</td><td>38.35</td><td>37.95</td><td>39.03</td></tr><tr><td>All Night CPAP (%)</td><td>19.85</td><td>20.88</td><td>18.5</td></tr></tbody></table><h2 id="Sleep-Stages"><a href="#Sleep-Stages" class="headerlink" title="Sleep Stages"></a>Sleep Stages</h2><p>根据美国睡眠医学学会（AASM）睡眠评分手册，MGH的临床工作人员对睡眠阶段进行了注释。 更具体而言，以下六个睡眠阶段在30秒连续间隔中被注释：wakefulness, stage 1, stage 2, stage 3, rapid eye movement (REM), and undefined.（觉醒，阶段1，阶段2，阶段3，快速眼动（REM）和未定义）。 表2列出了睡眠期间受试者的特征。</p><p><img src="/2018/04/16/科研（一）/1523840382156.png" alt="1523840382156"></p><h2 id="Arousals"><a href="#Arousals" class="headerlink" title="Arousals"></a>Arousals</h2><p>MGH认证的睡眠专家标记了会打断受试者的睡眠的唤醒所出现的波形。 注意到的觉醒分为：自然觉醒，呼吸相关觉醒（RERA），磨牙症，<strong>换气不足，低通气（hypoventilations hypopneas？区别</strong>），呼吸暂停（中枢性，阻塞性和混合性），发声，打鼾，周期性腿部运动，Cheyne-Stokes呼吸（潮式呼吸）或部分气道阻塞。</p><p><strong>Table 3:</strong> Number and types of arousals in the training set.</p><table><thead><tr><th>Target arousals</th><th></th></tr></thead><tbody><tr><td>Bruxism 磨牙</td><td>30</td></tr><tr><td>Cheyne-Stokes breathing 潮式呼吸[3]</td><td>3</td></tr><tr><td>Hypoventilation换气不足</td><td>4</td></tr><tr><td>Noise 噪音</td><td>1</td></tr><tr><td>Partial airway obstruction 部分气道堵塞</td><td>11</td></tr><tr><td>Periodic leg movement (PLM) 周期性腿动</td><td>36</td></tr><tr><td>Respiratory effort (RERA) 呼吸暂停</td><td>43,822</td></tr><tr><td>Snoring 打鼾</td><td>28</td></tr><tr><td>Spontaneous 自然觉醒</td><td>70</td></tr><tr><td>Total</td><td>44,005</td></tr><tr><td><strong>Non-target arousals</strong></td><td></td></tr><tr><td>Hypopnea 低通气</td><td>56,936</td></tr><tr><td>Central apnea</td><td>22,763</td></tr><tr><td>Mixed apnea</td><td>2,641</td></tr><tr><td>Obstructive apnea</td><td>32,547</td></tr><tr><td>Total</td><td>114,887</td></tr></tbody></table><p><strong>这个target是指标签数据还是目标数据？</strong></p><h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><p>受试者在夜间睡眠时记录各种生理信号，包括：脑电图（EEG），眼电图（EOG），肌电图（EMG），心电图（ECG）和血氧饱和度（SaO2）。 在表4中，我们列出了可用信号的完整列表。 使用国际10/20电极放置系统收集6个EEG通道（F3-M2，F4-M1，C3-M2，C4-M1，O1-M2，O2-M1）。 单导联心电图收集电极放置在胸骨附近的右锁骨下方并在左侧胸壁上方。 收集左眼EOG，将右耳EEG电极（M2）作为参考。 肌电图记录在下巴，胸部和腹部进行。 排除SaO2后，所有信号均采样至200 Hz，并以微伏测量。 为了分析方便，<strong>SaO2 was resampled to 到200Hz?</strong>，并以百分比的形式记录。</p><p><img src="/2018/04/16/科研（一）/1523841414382.png" alt="1523841414382"></p><p>为了压缩数据，所有信号都使用 the scale and offset approach从64位float转换为16位signed int。 挑战赛的数据存储在Matlab适应的WFDB信号文件中。</p><h2 id="Accessing-the-Data"><a href="#Accessing-the-Data" class="headerlink" title="Accessing the Data"></a>Accessing the Data</h2><p>数据库包含两种类数据，训练集和测试集，每个大小约为135G，每个训练集样本包含信号，头文件，唤醒文件</p><ol><li>tr03-0005.mat：包含信号数据的Matlab V4文件。</li><li>tr03-0005.hea：记录头文件 - 描述信号数据格式的文本文件。</li><li>tr03-0005.arousal：唤醒和睡眠阶段注释，采用WFDB注释格式。</li><li>tr03-0005-arousal.mat：一个Matlab V7结构的文件，包含挑战赛的睡眠阶段和目标唤醒事件，采样频率为200 Hz。</li></ol><h2 id="Data-Sample"><a href="#Data-Sample" class="headerlink" title="Data Sample"></a>Data Sample</h2><p><img src="/2018/04/16/科研（一）/1523850990475.png" alt="1523850990475"></p><p>我们可以从上图中看出，数据集包含了同一个受试者同一时间段内的14条数据，其中标签数据为第二条arousal，他会以蓝色纵向标记发生的时间点，如图中蓝线W（wakeness）代表了自然觉醒时间点，由于是人为标注，所以发生时间有误差，所以在标注点前后的信息都应纳入考量范围。</p><p><img src="/2018/04/16/科研（一）/1523860799468.png" alt="1523860799468"></p><h2 id="primary-ideas"><a href="#primary-ideas" class="headerlink" title="primary ideas"></a>primary ideas</h2><p>​    由于数据虽然进行了标注，但是并没有进行分割和分类，最好先对数据进行切割。通常ECG和通气具有周期性，可通过周期性进行分割迅练，但是其他数据并没有看到明显的周期性，所以分割方式还有待解决。</p><p>[ - ] 设想一</p><p>​    找到一种可以适应于所有这13种数据的方法，直接转变为13个输入进行训练。</p><p>[ - ] 设想二</p><p>​    对于不同种数据找到效果最好的不同方法分别训练最后投票判断特征。</p><p>[ - ] 设想三</p><p>​    首先对不同特征进行数据降维，找到与这个标签最相关的特征，然后分别进行机器学习然后，多维数据再进行设想二的方法进行学习。</p><p>[<strong>1]epworth 嗜睡量表</strong></p><p>爱泼沃斯嗜睡量表（Epworth Sleepiness Scale，ESS）是由澳大利亚墨尔本的Epworth医院设计的。临床应用结果表明，ESS是一种十分简便的患者自我评估白天嗜睡程度的问卷表。 </p><p><strong>附表：Epworth嗜睡量表（ESS）</strong></p><p>　　 在下列情况下你打瞌睡或睡着的可能性有多大？根据表中假设的8种场景，请在右边“打瞌睡的可能性”选项中做出选择：“0”代表不会打瞌睡，“1”代表打瞌睡的可能性很小，“2”代表打瞌睡的可能性中等，“3”代表很可能打瞌睡。</p><p>　　 1 坐着阅读书刊时</p><p>　　 2 看电视时</p><p>　　 3 在沉闷公共场所坐着不动时(如剧场、开会)</p><p>　　 4 连续乘坐汽车1小时无间断 5 条件允许情况下，下午躺下休息时</p><p>　　 6 坐着与人谈话时</p><p>　　 7 未饮酒午餐后安静地坐着</p><p>　　 8 遇到堵车，在停车的几分钟里</p><p>　　 注：上述分数相加得到总分。ESS评分标准为：总分0-8分正常；9-12分轻度异常；13-15分中度异常；大于16分重度异常。</p><p><strong>[2 ] CPAP</strong></p><p>持续正压通气(Continuous Positive Airway Pressure)，即用面罩将持续的正压气流送入气道．用此种方式给氧的机器称CPAP呼吸机。指在自主呼吸条件下，患者应有稳定的呼吸驱动力和适当潮气量，在整个呼吸周期内人为地施以一定程度的气道内正压，从而有利于防止气道萎陷，增加功能残气量，改善肺顺应性，并提高氧合作用。在这种模式下，呼吸机只维持一定的气道正压，不进行机械通气。仅限于有自主呼吸的患者。如果病人出现呼吸暂停，CPAP呼吸机可以根据预设的频率进行必要的机械通气，来保障患者的安全。</p><p>split night代表一开始不用呼吸机睡眠几小时，然后睡眠过程中，若果有OSAS的症状而且是中度到重度的，会弄醒你然后开始 使用呼吸机 </p><p>all night 睡觉开始时就开始用</p><p><strong>[3] 潮式呼吸</strong></p><p>潮式呼吸（Cheyne-Stokes respiration）又称陈-施呼吸，特点是呼吸逐步减弱以至停止和呼吸逐渐增强两者交替出现，周而复始，呼吸呈潮水涨落样。多见于中枢神经疾病、脑循环障碍和中毒等患者。潮式呼吸周期可长达30秒～2分钟，暂停期可持续5～30秒。</p><p>病因</p><p>一般认为是呼吸中枢对二氧化碳的反应性降低，亦即呼吸中枢兴奋的阈值高于正常值。血中二氧化碳的分压低于能兴奋呼吸中枢的阈值，因而呼吸暂停。待血中二氧化碳分压超过正常水平达到阈值时，才能兴奋呼吸中枢，使呼吸恢复，经一阵呼吸后，血中二氧化碳分压又下降到阈值水平以下，呼吸中枢又停止活动，呼吸停止。</p><p>鉴别诊断</p><p>间停呼吸又称Biots呼吸。表现为有规律的均匀呼吸几次后，停止一段时间，又开始均匀呼吸，即周而复始的间停呼吸。该呼吸与潮式呼吸不同，它每次呼吸深度相等，而非深浅起伏，呼吸暂停时间比潮式呼吸长，呼吸次数也明显减少，间停呼吸发生机制与潮式呼吸大致相同，但患者呼吸中枢抑制比潮式呼吸者更重、病情更严重，预后不良，多在呼吸完全停止前出现。引起间停呼吸的疾病与潮式呼吸大致相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;数据信息&quot;&gt;&lt;a href=&quot;#数据信息&quot; class=&quot;headerlink&quot; title=&quot;数据信息&quot;&gt;&lt;/a&gt;数据信息&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.physionet.org/challenge/2018
      
    
    </summary>
    
      <category term="科研" scheme="http://sdhmdhr123.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Git bash、cygwin、minGW、shell、cmd</title>
    <link href="http://sdhmdhr123.github.io/2018/04/12/bash%E3%80%81cygwin%E3%80%81minGW/"/>
    <id>http://sdhmdhr123.github.io/2018/04/12/bash、cygwin、minGW/</id>
    <published>2018-04-12T14:43:37.000Z</published>
    <updated>2018-04-12T14:43:37.530Z</updated>
    
    <content type="html"><![CDATA[<p>git bash、cygwin、minGW、shell</p><hr><h3 id="一天弄懂一件事"><a href="#一天弄懂一件事" class="headerlink" title="一天弄懂一件事"></a>一天弄懂一件事</h3><p>最近在装physionew的开发包（WFDB software package）时,我遇到了需要安装cygwin minGW才能安装的情况，我通过了解这两个编译环境，发现和gitbash很像。。于是乎我试了一下gitbash行不行……结果是不行的，所以他们其中的区别是什么呢？</p><p>首先我们要先了解一下这几个东西，首先先给个我个人理解上的定义便于我们总结，其实呢这几个东西都可以认作shell，一个“壳”，功能是为操作电脑硬件系统提供一个平台、一个界面，你可以从这个界面操作你的电脑执行你的命令。然后他们的不同点就是集成的操作环境不太一样，即一些操作符还有一些规则不太一样。</p><p>cmd是command的缩写，翻译过来是命令提示符，是一种基于dos系统的命令行程序，一般都在windows系统下面用，功能上基本上是这几个里面最弱的了吧。。。基本上人家有的他们有 ，他有的别的都有。</p><p>shell：是运行在linux系统的“cmd”，但是功能要强大很多，接近于一门语言。</p><p>git bash：其实是为了在cmd的基础上封装了一些unix下的命令脚本，以及一些git自己相关的脚本</p><p>cygwin：当看到cygwin的时候我一下就想到了git bash 想着能不能直接用git bash，毕竟装那么多环境我会感觉很混乱，然后试了一下，出错，说是缺少gcc包什么的，看来相比较起来，cygwin在windows模拟linux环境上还是更胜一筹。</p><p>minGW：和cygwin功能上类似，但是实现方法貌似不一样。没打算用就没过多关注。</p><hr><p>后记：cygwin占空间很大，大概10G+的样子这还是我只装了一个devel包的情况下，后来在想运行wfdb的时候，说还缺少其他的包，我就索性把它删了直接用服务器好了，但是有个致命的问题。。。最后cygwin的那个数据包竟然删不掉，原因是系统正在运行cygwin，wtf？我都删了好伐。。。看了很多文章都是说删了注册表或者用安装过程中把install改成uninstall就行，最后也不成功。。360的强力删除也不行，目前的结果只能是放任这个包占用着3G的空间不管他了，，，还好我的强迫症并不严重。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git bash、cygwin、minGW、shell&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一天弄懂一件事&quot;&gt;&lt;a href=&quot;#一天弄懂一件事&quot; class=&quot;headerlink&quot; title=&quot;一天弄懂一件事&quot;&gt;&lt;/a&gt;一天弄懂一件事&lt;/h3&gt;&lt;p&gt;最近在装physio
      
    
    </summary>
    
    
      <category term="GNU" scheme="http://sdhmdhr123.github.io/tags/GNU/"/>
    
      <category term="环境" scheme="http://sdhmdhr123.github.io/tags/%E7%8E%AF%E5%A2%83/"/>
    
      <category term="编译器" scheme="http://sdhmdhr123.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow理解</title>
    <link href="http://sdhmdhr123.github.io/2018/04/12/tensorflow%E7%90%86%E8%A7%A3/"/>
    <id>http://sdhmdhr123.github.io/2018/04/12/tensorflow理解/</id>
    <published>2018-04-12T14:42:57.000Z</published>
    <updated>2018-05-07T07:48:34.385Z</updated>
    
    <content type="html"><![CDATA[<p>以前一直没搞明白tensorflow的概念，现在好像又多了一点点理解。</p><p>tensor代表张量，但是只是保存的计算过程，并不是真正的数据，包含的内容是名称，类型，维度，但是只是一个过程，没有具体的数字。flow当然就是数据流过这些过程，然后输出一个结果。</p><p>所以呢，tensorflow的概念就是也是一个包，框架框架的感觉有点晕晕的，框架和库其实是一种抽象的描述，即框架是你可以拿来进行二次开发的一个基础，而库是一个工具箱，他们和包有点类似于平行的概念，包里可以有框架和库。</p><p>有人说了scikit-learn不也是一个机器学习包，也是封装了一些现成算法，和tensorflow有什么区别呢？诶，区别还真有，第一他是个包，所以就没有tensorflow的运算特性了，不能用GPU，所以呢就是运行比较慢。同时，就目前而言的我的理解，scikit-learn只是封装算法，你到时候可以调用，其他的该你自己写还是你自己写，而tensorflow呢是搭乐高积木，一块搭一块（但其实我感觉写起来还是自己写）。但是呢，scikit-learn的功能其实是比tensorflow更齐全的，在这个方面可以把tensorflow看成python，scikit-learn是c++，就是有点类似这么个区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前一直没搞明白tensorflow的概念，现在好像又多了一点点理解。&lt;/p&gt;
&lt;p&gt;tensor代表张量，但是只是保存的计算过程，并不是真正的数据，包含的内容是名称，类型，维度，但是只是一个过程，没有具体的数字。flow当然就是数据流过这些过程，然后输出一个结果。&lt;/p&gt;
      
    
    </summary>
    
      <category term="感悟" scheme="http://sdhmdhr123.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>当Conda找不到所需要的包时</title>
    <link href="http://sdhmdhr123.github.io/2018/04/12/%E5%BD%93conda%E6%89%BE%E4%B8%8D%E5%88%B0%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%8C%85%E6%97%B6/"/>
    <id>http://sdhmdhr123.github.io/2018/04/12/当conda找不到所需要的包时/</id>
    <published>2018-04-12T13:30:05.000Z</published>
    <updated>2018-04-12T13:32:30.016Z</updated>
    
    <content type="html"><![CDATA[<p>比如找不到 pyqt5<br>anaconda search -t conda pyqt5<br>会得到一堆列表<br>Packages:</p><pre><code>Name                      |  Version | Package Types   | Platforms      ------------------------- |   ------ | --------------- | ---------------abergeron/pyqt5           |    5.4.1 | conda           | osx-64         andreas-h/pyqt5           |    5.3.2 | conda           | linux-64, win-64, osx-64asmeurer/pyqt5            |    5.3.2 | conda           | osx-64         astrofrog/pyqt5           |    5.5.0 | conda           | linux-64  </code></pre><p>…</p><p>Run ‘anaconda show <user package="">‘ to get installation details<br>(my_research) root@iZwz9194z8s66bnyjsuuagZ:~# anaconda show conda-forge/wfdb</user></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;比如找不到 pyqt5&lt;br&gt;anaconda search -t conda pyqt5&lt;br&gt;会得到一堆列表&lt;br&gt;Packages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Name                      |  Version | Package Types
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下的fish</title>
    <link href="http://sdhmdhr123.github.io/2018/04/12/fish/"/>
    <id>http://sdhmdhr123.github.io/2018/04/12/fish/</id>
    <published>2018-04-12T12:47:39.000Z</published>
    <updated>2018-04-16T02:44:31.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Fish 是”the friendly interactive shell”的简称，最大特点就是方便易用。很多其他 Shell 需要配置才有的功能，Fish 默认提供，不需要任何配置。</p><p>如果你想拥有一个方便好用的 Shell，又不想学习一大堆语法，或者花费很多时间配置，那么你一定要尝试一下 Fish。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017050204.png" alt="img"></p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p>Ubuntu 和 Debian 的安装方法。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ sudo apt-get install fish</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>Mac 的安装方法。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ brew install fish</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>其他系统的安装请参考<a href="http://fishshell.com/#platform_tabs" target="_blank" rel="noopener">官方网站</a>。</p><h2 id="三、启动与帮助"><a href="#三、启动与帮助" class="headerlink" title="三、启动与帮助"></a>三、启动与帮助</h2><p>安装完成后，就可以启动 Fish。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ fish</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>由于 Fish 的语法与 Bash 有很大差异，Bash 脚本一般不兼容。因此，我建议不要将 Fish 设为默认 Shell，而是每次手动启动它。</p><p>使用过程中，如果需要帮助，可以输入<code>help</code>命令。浏览器就会自动打开，显示在线文档。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ <span class="built_in">help</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="四、彩色显示"><a href="#四、彩色显示" class="headerlink" title="四、彩色显示"></a>四、彩色显示</h2><p>进入 Fish 以后，你注意到的第一件事，可能就是它默认彩色显示。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 无效命令为红色</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ mkd</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 有效命令为蓝色</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ mkdir</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>有效路径会有下划线。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ cat ~/somefi </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码表示，存在以<code>~/somefi</code>开头的路径。如果没有下划线，你就知道这个路径不存在。</p><h2 id="五、自动建议"><a href="#五、自动建议" class="headerlink" title="五、自动建议"></a>五、自动建议</h2><p>Fish 会自动在光标后面给出建议，表示可能的选项，颜色为灰色。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 命令建议</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ /bin/hostname</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 参数建议</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ grep --ignore-case</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 路径建议</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ ls node_modules</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>如果采纳建议，可以按下<code>→</code>或<code>Control + F</code>。如果只采纳一部分，可以按下<code>Alt + →</code>。</p><h2 id="六、自动补全"><a href="#六、自动补全" class="headerlink" title="六、自动补全"></a>六、自动补全</h2><p>输入命令时，Fish 会自动显示匹配的上一条历史记录。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git commit -m <span class="string">"feat: first commit"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>如果没有匹配的历史记录，Fish 会猜测可能的结果，自动补全各种输入。比如，输入<code>pyt</code>再按下<code>Tab</code>，就会自动补全为<code>python</code>命令。</p><p>如果有多个可能的结果，Fish 会把它们都列出，还带有简要介绍。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ vi[按下 Tab 键]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vi (Executable link, 2.7MB)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> view (Vi IMproved, 一个程序员的文本编辑器)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> viewer.py (Executable, 967B)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> viewres  (Graphical class browser <span class="keyword">for</span> Xt)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ...and 12 more rows</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>这时，再按一次<code>tab</code>，就可以在这些命令之中选择。</p><p>除了补全命令，Fish 还可以补全参数。比如，<code>ls</code>命令的<code>-l</code>参数后面按下<code>Tab</code>键，就会显示可以连用的其他参数。</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $ ls -l[按下 Tab 键]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -l1  (List one file per line)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lA  (Show hidden except . and ..)  </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -la  (Show hidden)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> -lB  (Ignore files ending with ~)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ...and 16 more rows</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Fish 还可以自动补全 Git 分支。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>$ git checkout master<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 七、易懂的语法</span><br><span class="line"></span><br><span class="line">Fish 的语法非常自然，一眼就能看懂。</span><br><span class="line"></span><br><span class="line">`<span class="keyword">if</span>`语句。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>if grep fish /etc/shells<br>    echo Found fish<br>else if grep bash /etc/shells<br>    echo Found bash<br>else<br>    echo Got nothing<br>end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`switch`语句。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>switch (uname)<br>case Linux<br>    echo Hi Tux!<br>case Darwin<br>    echo Hi Hexley!<br>case FreeBSD NetBSD DragonFly<br>    echo Hi Beastie!<br>case ‘*’<br>    echo Hi, stranger!<br>end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`while`循环。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>while true<br>    echo “Loop forever”<br>end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`f<span class="literal">or</span>`循环。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>for file in *.txt<br>    cp $file $file.bak<br>end<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 八、函数</span></span></span><br><span class="line"></span><br><span class="line">Fish 的函数用来封装命令，或者为现有的命令起别名。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>function ll<br>    ls -lhG $argv<br>end<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面代码定义了一个`ll`函数。命令行执行这个函数以后，就可以用`ll`命令替代`ls -lhG`。其中，变量`$argv`表示函数的参数。</span><br><span class="line"></span><br><span class="line">下面是另一个例子。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>function ls<br>    command ls -hG $argv<br>end<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的代码重新定义`ls`命令。注意，函数体内的`ls`之前，要加上`command`，否则会因为无限循环而报错。</span><br><span class="line"></span><br><span class="line">## 九、提示符</span><br><span class="line"></span><br><span class="line">`fish_prompt`函数用于定义命令行提示符（prompt）。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>function fish_prompt<br>    set_color purple<br>    date “+%m/%d/%y”<br>    set_color FF0<br>    echo (pwd) ‘&gt;’<br>    set_color normal<br>end<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行上面的函数以后，你的命令行提示符就会变成下面这样。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></p><p>02/06/13<br>/home/tutorial &gt;<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 十、配置</span><br><span class="line"></span><br><span class="line">Fish 的配置文件是`~/.config/fish/config.fish`，每次 Fish 启动，就会自动加载这个文件。</span><br><span class="line"></span><br><span class="line">我们可以在这个文件里面写入各种自定义函数，它们会被自动加载。比如，上面的`fish_prompt`函数就可以写在这个文件里面，这样每次启动 Fish，就会出现自定义的提示符。</span><br><span class="line"></span><br><span class="line">Fish 还提供 Web 界面配置该文件。</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>$ fish_config<br>```</p></blockquote><p>输入上面的命令以后，浏览器就会自动打开本机的 8000 端口，用户可以在网页上对 Fish 进行配置，比如选择提示符和配色主题。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017050203.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;Fish 是”the friendly interactive shell”的简称，最大特点就是方便易用。很多其他 Shel
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>应聘华为实习生</title>
    <link href="http://sdhmdhr123.github.io/2018/04/02/%E5%BA%94%E8%81%98%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    <id>http://sdhmdhr123.github.io/2018/04/02/应聘华为实习生/</id>
    <published>2018-04-02T05:49:14.000Z</published>
    <updated>2018-04-12T14:58:01.093Z</updated>
    
    <content type="html"><![CDATA[<p>华为实习生应聘经历、</p><hr><p>今年大概3月份吧，华为应该是最早的来我们学校来宣讲的，宣讲的时候讲了好多优惠条件，比如实习工资6000、面试笔试不过不影响秋招，面试过了不去到秋招的时候也可以免去前面步骤直接终面。同时由于我老师又不管我，所以打算试一试找个研发岗的实习。</p><p>大概在截止日之前我提交了自己的简历，emm……生物狗转行，申算法工程师，项目经历和实践经历都是空白，只填了个人信息和教育经历。不过还得说母校牌子是真滴好用，没几天就通知我笔试。</p><p>###笔试</p><p>说起笔试，还是有点波折的，一开始华为发给我的笔试通知附带了模拟题和最后实际操作的链接，我看了一眼模拟题，竟然有只允许用C写的程序，瞬间就没有斗志了，又考虑到笔试那天晚上有课，就选了不参加。   后来打听了一下其他的同学应聘这个岗的，发现他们也都不会做，而且说三道题只要做对一道就可以。。。。。。。wtf，我以为正常电子的或者稍微比我对口的专业写这个都该是手到擒来，结果都是摸着石头过河。。。白瞎了我对他们对口专业学生的仰望。。。。</p><p>不过还好，因为我上次选择了不参加，华为又发了一封邮件让我重新测试。emm这次其实还是没谱，但最主要的一点是我发现牛客网编程题是可以切出网页的，那就意味着有些用法可以现查，这就大大减轻了我的负担。而且人家华为又给我一次机会，这次说啥也不能不去了，虽然还是tmd周三又有课。</p><p>最后我从三个题里选了个最简单的写完了就直接交卷了，然后就去上课了。过程emm大概也就40来分钟。其实这三道题第一道我没看懂题目直接跳过，第三道其实也挺简单，但是为了上课（没错我就是这么爱学习）就也没做，反正一道就可以，点到为止，给他笔试题一个面子。后来我又看了他们第一次笔试的题，，比我的难多了，，，我命真好。。。</p><p>大概不到一周吧，面试通知就发过来了，4.1喜来登酒店建议着西装。。。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>还沉浸于过了笔试的喜悦之中的我收集了一下算法岗的面试题的范围。。。。。。。也太多了把，混过了笔试还有这么难的面试，通知和面试时间隔了两天半，我打算趁此突击一下。</p><p>第一天，充满干劲，哇这个好厉害，可能考，哇那个好厉害，也可能考</p><p>第二天……看个球……弃疗，还是打游戏把。。。</p><p>不过还好，我还有一手，因为我是下午面试，所以能跟上午的同学问问大概问的啥。有一个同学告诉我他的题目是手写遍历二叉树，然后在排个序。还有一个是弄一个网络，<em>&amp;</em>&amp;！？？？**（——（&amp;&amp;  根本没看懂，也没记住，虽然已经弃疗了，我还是抱着侥幸心理看了一下python的二叉树遍历和实现，然后自己写了个冒泡和快排，然后我表示我已经尽力了，三分天注定，七分靠打拼，剩下的90分就看脸了。</p><p>华为通知写了个建议着西装，我借了半天也没借全一套。心一横：哥是谁，就是这么特立独行。我穿着休闲装去了。。。去了之后发现4/5都是西装革履，，，</p><p>去的过程中，还和同行的同学聊了一下，他说二叉树很简单呀，我可以发你看一下，然后我就又看了一遍。到了面试现场，之前和我一直有联系的HR小哥人特别好，跟我聊了聊，说别紧张，没事，就是考冒泡二叉树之类的，你放轻松，稍微准备准备就行，所以我就叒看了一遍二叉树。结果你猜怎么，<strong>TMD还真就考了二叉树</strong> ，我的运气是真的好。。。。。</p><p>不过也不仅仅是二叉树了，二叉树之后又写了两个变形，排了一下序，又填充了一下二叉树，还用上了我现看的队列。。（我是真的运气好）。过程中面试官见到我的简历都很尴尬，没什么问的，就只能让我写算法。。。所以我一面很快，二十分钟就完了，正常有项目的话大概30分钟以上。</p><p>然后就是二面了，基本就是聊了聊基本情况，聊了一下科研和工作意向啥的。具体细节也忘了，虽然面试官笑呵呵的，但是我对他印象不是很好，可能是他在考察我什么东西所以有些问题问的比较尖锐把。</p><p>再后来说让我回来等信息，我听说大概两周才有结果吧，华为面试就告一段落了。。<strong>然而，我又收到了4.3笔试网易测试工程师的通知…………</strong></p><hr><p>更新：华为面试没过。。。。我当时面完感觉还可以，现在分析分析原因可能是没带简历，电子简历上也没填任何经历。导致印象不好吧。还有就是笔试因为有课我并没有全做，只做了一个。再找其他原因可能是性格测试和面试官当时问的问题并没有给出他想要的答案吧。。。。反正是G了。。果然面试还是很难得。</p><p>顺带提一句网易游戏的机试题是真的难。。。感觉这个暑期估计没得实习可以去了，初步打算好好搞个科研，秋招再找一下工作吧。找不到就积极准备选调生，毕竟这个应该不需要太多的实习经历。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;华为实习生应聘经历、&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;今年大概3月份吧，华为应该是最早的来我们学校来宣讲的，宣讲的时候讲了好多优惠条件，比如实习工资6000、面试笔试不过不影响秋招，面试过了不去到秋招的时候也可以免去前面步骤直接终面。同时由于我老师又不管我，所以打算试一试找个研发岗
      
    
    </summary>
    
      <category term="感悟" scheme="http://sdhmdhr123.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="实习" scheme="http://sdhmdhr123.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
      <category term="面试" scheme="http://sdhmdhr123.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>写文章也太麻烦了</title>
    <link href="http://sdhmdhr123.github.io/2018/03/27/%E5%86%99%E6%96%87%E7%AB%A0%E4%B9%9F%E5%A4%AA%E9%BA%BB%E7%83%A6%E4%BA%86/"/>
    <id>http://sdhmdhr123.github.io/2018/03/27/写文章也太麻烦了/</id>
    <published>2018-03-27T13:18:06.000Z</published>
    <updated>2018-03-27T13:44:06.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写了几篇博客才发现，写技术博客是真滴难"><a href="#写了几篇博客才发现，写技术博客是真滴难" class="headerlink" title="写了几篇博客才发现，写技术博客是真滴难"></a>写了几篇博客才发现，写技术博客是真滴难</h2><p>本来是打算平时写写技术博客，记录一下自己学习的东西，除了方便查阅，和其他人分享一下经验与遇到的坑，最主要的用途其实还是面试的时候“啪”往面试官脸上一拍，露出“绝世强者”的笑容。</p><p>但写了几天才发现，写博客是真滴难。有可能是我自己太菜的原因，看到什么不会的都想解释一番，一写就是半小时，一写就是半小时，结果几天下来，自己的项目和学习的进度及其缓慢。内容的宽度倒是挺宽，杂七杂八啥都有，但是就是没有个有用的。在一个就是我这些写的基本都是自己纯手打，除了部分段落和代码是粘贴的，几乎每篇我都自己加了自己的理解，所以导致一天除了学习，有一半时间都用来记录了，成为了一名光荣的打字员。</p><p>所以就以上情况，我觉得是时候改变自己博客的写作方向了。给博客制定一些明确的规则和风格。</p><ol><li>网上资料特别丰富的教程及技术的方向就不记录了，例如我之前写的那个hexo建博客的那篇，感觉就没啥用，写的还没人全。不过呢，可以记录一下技术及方法，直接粘过来，当做字典用。这一类category全部命名 ”参考“。</li><li>英语类直接取消，从薄荷阅读荡下来感觉比抄写效率还低，直接放弃。</li><li>每天用于记录的时间保持在所有学习时间的1/5左右，写作原则——简洁，不要夹带自己那么多私货。</li><li>技术博客主要记录三方面：自己的项目、学习总结、按照别人方案搞遇到的坑。category 命名 “技术博文”</li><li>大方向上，只保持三个板块：技术博文，参考，感悟。</li></ol><p>嗯，总结的差不多了，感觉明天又是朝气满满的一天呢。</p><p>ps：感觉自己这种阶段性flag经常立，经常崩，经常搞着搞着偏离的主线，时间紧任务重，毕业好难。</p><p>再立个flag，实习能找就找，找不到安心自学，在毕业之前没实习没工作至少把项目做好一点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写了几篇博客才发现，写技术博客是真滴难&quot;&gt;&lt;a href=&quot;#写了几篇博客才发现，写技术博客是真滴难&quot; class=&quot;headerlink&quot; title=&quot;写了几篇博客才发现，写技术博客是真滴难&quot;&gt;&lt;/a&gt;写了几篇博客才发现，写技术博客是真滴难&lt;/h2&gt;&lt;p&gt;本来
      
    
    </summary>
    
      <category term="感悟" scheme="http://sdhmdhr123.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="烦" scheme="http://sdhmdhr123.github.io/tags/%E7%83%A6/"/>
    
  </entry>
  
  <entry>
    <title>类和对象</title>
    <link href="http://sdhmdhr123.github.io/2018/03/27/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sdhmdhr123.github.io/2018/03/27/类和对象/</id>
    <published>2018-03-27T11:29:25.393Z</published>
    <updated>2018-03-27T13:59:28.608Z</updated>
    
    <content type="html"><![CDATA[<p>对象（object）<br>广义上是指内存上一段有意义的区域。<br>狭义上是指把一组数据结构和处理他们的方法结合起来叫做对象。把相同行为的对象叫做类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）/泛化(generalization)，通过多态（polymorphism）实现基于对象类型的动态分派。<br>面相对象（objected oriented）<br><img src="https://pic7.zhimg.com/80/664ba37eeee9f4623c06c066867f1d38_hd.jpg" alt="example1"><br>类：可以理解为可以量产对象，但是产生的可以不同<br>封装：就是知道名字可以使用，但是具体怎么实现的不知道<br>继承：子类能继承父类的功能例如<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Mylist</span>(<span class="title">list</span>):</span></span><br><span class="line"><span class="class">pass</span></span><br><span class="line"><span class="class">a = <span class="type">Mylist</span>()</span></span><br><span class="line"><span class="class">a.append(5)</span></span><br><span class="line"><span class="class">这里<span class="type">Mylist</span> 就继承了list的功能。</span></span><br></pre></td></tr></table></figure></p><p>目前就我的理解，可以把类比作汽车，那停和启动就是方法，函数中通常不会封装数据，只是执行某种功能但是类中有。<br>多态：是同一个功能函数在不同的类里执行的功能可能不同（我感觉这就是废话，为什么会当成一个特征。）<br>python中的类的self其实就是相当于c++的this指针，对象自身会当做第一个参数传给self，self相当于每个房子的门牌号。类相当于设计图纸。对象就是长得很像但不是一个的房子。类：都是人，对象：但人又都不相同<br>类中可以内置一些方法，用双下横线包围<br><code>__init__(self，param1,param2=&#39;example&#39;)</code><br>你不写他也有个<code>__init__(self)</code><br>和c++的构造函数一样<br>name mangling:在私有变量或者函数前面加上两个_就可以了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">__name =<span class="string">"小甲鱼"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">returen <span class="keyword">self</span>.__name</span><br></pre></td></tr></table></figure></p><p>直接调用 p.<strong>name是不行的<br>用p.getName() p._Person</strong>name就行  python类没有权限控制，所以是伪私有。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climb</span><span class="params">(<span class="keyword">self</span>)</span></span>:  </span><br><span class="line">print(<span class="string">'ddasdfa'</span>)</span><br></pre></td></tr></table></figure><ul><li>当程序员不想把同一段代码写几次，他们发明了函数解决了这种情况。当程序员已经有了一个类，而又想建立一个非常相近的类，可以用继承的方法。  </li><li>self是对象自身作为的第一个参数传入。  </li><li>如果我们不希望对象的属性和方法被外部直接引用，我们可以设置私有变量或者函数，但实际上还是引用的到。  </li><li>类在实例化后<strong>init</strong>(self)函数会被自动调用，init 是initialize的缩写。  </li></ul><p>继承中,子类方法如果和父类方法（即函数）重名，则子类方法会把父类方法给覆盖掉。所以这里面有两种技术可以实现不覆盖。一种是<br><code>Fish.__init__(self)</code>调用父类fish，其实就等于<code>Fish.__init__(shark)</code>,shark 是子类方法。<br>另一个更好用得是super(),多重继承时特别好用。<code>super.__init__()</code><br>多重继承虽然很好用，但是容易引起代码混乱，所以在不确定的时候，最好不要用多重继承，会造成不可预见的bug，例如菱形继承或者叫做钻石继承，这个很致命。  </p><ul><li>继承机制为程序员带来的明显的好处就是写的代码量少了。</li><li>当子类定义了与父类相同名字的属性或方法时，python不会删除父类的方法或属性，但在对象调用子类继承父类时，其父类的方法或属性会被子类方法或属性给覆盖。</li><li>如果要屏蔽父类中的某些属性，利用覆盖机制就可以，将那条方法写在子类后面，写一个pass就可以</li><li>super超级的地方就在于不用再将父类的名字再打一遍，而且适用于多重继承。同时，由于你不用给出基类的名字，这就意味着如果你需要改变类继承关系，你只需要改变class里的父类即可。而不用去各个代码中寻找父类的名字。</li><li><strong>init</strong>(self)方法里不能有return ，因为这个方法不能反悔除None以外的任何对象，主要是用来给一些初始化定义。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, x=<span class="number">0</span>, y=<span class="number">0</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.x = x</span><br><span class="line">        <span class="keyword">self</span>.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getX</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getY</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, p1, p2)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.x = p1.getX() - p2.getX()</span><br><span class="line">        <span class="keyword">self</span>.y = p1.getY() - p2.getY()</span><br><span class="line">        <span class="keyword">self</span>.len = math.sqrt(<span class="keyword">self</span>.x*<span class="keyword">self</span>.x + <span class="keyword">self</span>.y*<span class="keyword">self</span>.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLen</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.len</span><br><span class="line"></span><br><span class="line">p1 = Point(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">p2 = Point(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">line = Line(p1, p2)</span><br><span class="line">print(line.getLen())</span><br></pre></td></tr></table></figure><p>上面代码中并没有用到继承，传入line的是两个对象，对象自带属性和方法，在传入其他类后对其进行操作时可直接调用对象的方法和属性。  </p><p>###组合<br>组合是指把没有直接关系的类放在一起叫做组合, in another word,所谓组合就是把类和实例化放在一个新的类里面，这样就不用继承了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,x)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.num = x</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,y)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,x,y)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.turtle = Turtle(x)</span><br><span class="line"><span class="keyword">self</span>.fish = Fish(y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_num</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">print(<span class="string">"there were %d turtles and %d fish"</span><span class="string">%(self.turtle.num,self.fish.num)</span>) </span><br><span class="line">这里不能直接用<span class="keyword">self</span>.turtle, 因为 <span class="keyword">self</span>.turtle = Turtle(x) 是一个实例化对象，并不是一个实际的方法或属性</span><br></pre></td></tr></table></figure></p><p>###Min-in 编程机制</p><p>mixin 是一种开发模式，是一种将多个类中的功能单元进行组合利用的方式，这听起来有点像类的继承，但是不太一样。通常mixin不作为任何类的基类，也不关心和什么类一起使用，而是在运行时动态的同其他的零散的类一起组合使用。 下面提到的多继承和<strong>bases</strong>方法都是基于这个机制。</p><p>####多继承<br>Python支持多继承，即一个子类可以继承多个父类，利用这个特性，我们就可以利用mixin机制实现ab功能的组合。    </p><p>####<strong>bases</strong>  ：一种类的组合机制<br>多继承的实现会创建出新的类，在我们希望给A类添加B类的功能时，我们可以利用python元编程特性实现。<br>元编程meta-programming（这古文翻译，不懂古文的还真有点看不懂），写用来生成代码的代码。<br>感觉就是一种手工压缩代码量的感觉，元编程操作的对象是其他代码。<br>继续说多继承，举个栗子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_a</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_b</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span> </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.get_a()</span><br><span class="line">c.get_b()</span><br><span class="line"></span><br><span class="line">A.__bases__ += (B,)</span><br><span class="line">a.get_b()</span><br></pre></td></tr></table></figure></p><p>其实<strong>bases</strong>也是继承的机制，，因为<strong>bases</strong>属性存储了类的基类。因此多继承的方法也可以这样实现。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">C</span>:</span></span><br><span class="line"><span class="class">    pass</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="type">C</span>.__bases__ += (<span class="type">A</span>, <span class="type">B</span>, )</span></span><br></pre></td></tr></table></figure></p><p>还有另一种方式：插件方式，比较麻烦，如果用到，再看不迟<strong>dict</strong>。<a href="http://bbs.fishc.com/thread-48888-1-1.html" target="_blank" rel="noopener">参考链接</a></p><p> 类、类对象和实例对象。<br>类属性和类对象相互绑定，所以实例对象改变不会影响类对象，实例对象改变会覆盖类方法<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">a=C()</span><br><span class="line">b=C()</span><br><span class="line">c=C()</span><br><span class="line"><span class="selector-tag">a</span>.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="selector-tag">b</span>.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line">c.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line">c.count+=<span class="number">10</span></span><br><span class="line">c.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line">C.count</span><br><span class="line"><span class="number">0</span></span><br><span class="line">C.count+=<span class="number">100</span></span><br><span class="line"><span class="selector-tag">a</span>.count</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="selector-tag">b</span>.count</span><br><span class="line"><span class="number">100</span></span><br><span class="line">c.count</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><ul><li>一个整形是不能调用的，属性名和方法名相同，属性会覆盖方法。  </li><li>类的定义要少吃多餐，不要在一个类中放上所有想到的方法和属性，尽量利用继承和组合机制进行扩展类。  </li><li><p>有不同的磁性的名字命名类。名词动词词性分开。  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = C()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c.x =<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c.x()</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;pyshell#24&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line">    c.x()</span><br><span class="line"><span class="symbol">TypeError:</span> <span class="string">'int'</span> object is <span class="keyword">not</span> callable</span><br></pre></td></tr></table></figure></li><li><p>什么时候用组合，什么时候用继承？<br>根据实际的应用场景确定。简单地说，组合适用于“有一个”的场景，继承适用于“是一个”的场景。例如有一个鱼，有一个猫有一个大象。鲨鱼是鱼，青瓜是瓜。 </p></li><li>类对象是什么时候产生的？<br>-当你这个类定义完的的时候，类定义就变成类对象。python是一切皆对象，可以用‘类名.属性’或‘类名.方法’来调用类对象。</li></ul><p>####设计一个跟踪一个类里有多少实例被创建的代码<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">                C.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">                C.count -= <span class="number">1</span> <span class="comment">#实际上我不懂这一段代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; a = C()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; b = C()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; c = C()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; C.count</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; del a</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; C.count</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; del b, c</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; C.count</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>###与类相关的BIF（内置函数）<br>issubclass(class,classinfo)<br>一个类是自身的子类；classinfo可以使类对象组成的元组，只要class与其中任何一个候选类的子类，则返回True  </p><p>object 是所有类的子类<br>issubclass(B,object)</p><p>isinstance(object,classinfo)<br>检查是否是实例对象<br>第一个如果不传入实例对象，全是false<br>可以传入一个元组类  </p><h4 id="BIF-比较斯文的访问属性"><a href="#BIF-比较斯文的访问属性" class="headerlink" title="BIF 比较斯文的访问属性"></a>BIF 比较斯文的访问属性</h4><p>hasattr(object,’name’)<br>getattr(object,name[,default])<br>getattr(a,’x’,’你所访问的属性不存在’)<br>setattr(object,’name’,’value’)<br>delattr(object,’name’)<br>property(fget =None,fset=None,fdel=None,doc =None) 返回值是一个属性<br>a = property(getsize,setsize,delsize)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c<span class="selector-class">.a</span> = <span class="number">18</span>  </span><br><span class="line"><span class="selector-tag">del</span> c1<span class="selector-class">.a</span>  </span><br><span class="line">c.a</span><br></pre></td></tr></table></figure></p><p>property 主要功能是提供一个借口，再调用是只需要知道 a 不用知道里面改变了啥。  </p><p>###描述符<br>描述符就是将某种特殊类型的类的实例指派给另一个类的属性。<br><strong>get</strong>  <strong>set</strong> <strong>del</strong>是特殊类型<br>property就是一个描述符类。可以自己定义一个<br>instance 是实例拥有者的实例对象，owner 是实例拥有者<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myproperty</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,fget = None,fset=None,fdel =None)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.fget=fget</span><br><span class="line"><span class="keyword">self</span>.gset = gset</span><br><span class="line"><span class="keyword">self</span>.del=fdel</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(<span class="keyword">self</span>,instance,owner)</span></span>:   <span class="comment">#不赋值直接调用时</span></span><br><span class="line">reutrn <span class="keyword">self</span>.fget(instance)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(<span class="keyword">self</span>,instance,value)</span></span>:   <span class="comment">#赋值时所调用的</span></span><br><span class="line"><span class="keyword">self</span>.fset(instance,value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(<span class="keyword">self</span>,instance)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>.fdel(instance)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>._x = None</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getX</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>._x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setX</span><span class="params">(<span class="keyword">self</span>,value)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="keyword">self</span>._x=value</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delX</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">del <span class="keyword">self</span>._x</span><br><span class="line">x = Myproperty(getX,setX,delX)</span><br><span class="line"><span class="comment">#可以说myproperty是x的描述符  class myproperty（）是描述符类</span></span><br></pre></td></tr></table></figure></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Celsius</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>,value=<span class="number">26.0</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.value=float(value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(<span class="keyword">self</span>,instance,owner)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(<span class="keyword">self</span>,instance,value)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.value = float(value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fahrenheit</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(<span class="keyword">self</span>,instance,owner)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> instance.cel*<span class="number">1.8</span>+<span class="number">32</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(<span class="keyword">self</span>,instance,value)</span></span><span class="symbol">:</span></span><br><span class="line">        instance.cel = (float(value)-<span class="number">32</span>)/<span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temperature</span>:</span></span><br><span class="line">    cel = Celsius()</span><br><span class="line">    fah = Fahrenheit()</span><br><span class="line"></span><br><span class="line">tmp=Temperate()</span><br><span class="line">tem.cel= <span class="number">30</span> 这是对Tem实例的cel属性进行赋值执行__set_<span class="number">_</span>方法</span><br><span class="line">然后instance.cel也就是是tem.cel</span><br><span class="line">也就是说这里面赋值其实都是给cel ，fah执行的只是给这个数进行了转换</span><br></pre></td></tr></table></figure><h3 id="定制序列"><a href="#定制序列" class="headerlink" title="定制序列"></a>定制序列</h3><p>协议与其他编程语言中的接口相似，他规定你哪些方法必须要定义。然而python中更像是一种指南。<br>定制序列就是定制容器，数据容器就是列表list，词典dict，元组tuple.<br>如果你希望你的容器不可修改你只需要定制 <strong>len</strong>() and <strong>getitem</strong>()<br>如果你希望你的容器可修改还得加上<strong>setitem</strong>() and <strong>delitem</strong>()<br>[x for x in arg]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象（object）&lt;br&gt;广义上是指内存上一段有意义的区域。&lt;br&gt;狭义上是指把一组数据结构和处理他们的方法结合起来叫做对象。把相同行为的对象叫做类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（sp
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
      <category term="python" scheme="http://sdhmdhr123.github.io/tags/python/"/>
    
      <category term="概念" scheme="http://sdhmdhr123.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="http://sdhmdhr123.github.io/2018/03/27/markdown%20grammer%20learning/"/>
    <id>http://sdhmdhr123.github.io/2018/03/27/markdown grammer learning/</id>
    <published>2018-03-27T11:29:25.392Z</published>
    <updated>2018-03-27T13:58:22.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-Grammer-Learning"><a href="#Markdown-Grammer-Learning" class="headerlink" title="Markdown Grammer Learning"></a>Markdown Grammer Learning</h1><h3 id="目标：易读易写"><a href="#目标：易读易写" class="headerlink" title="目标：易读易写"></a>目标：易读易写</h3><p>特点： 与word相比较而言极其轻量级，在操作上习惯后会觉得比word简便。在跨平台方面更出色。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”（具体意义就是可以直接往网上发不用再排版，还记得你从word往网站上发布时需要重新排版的情形吗？）。<br>简单点，用Markdown写作就是能够实现边输文字边排好版，根本用不上鼠标，根本不用苦苦地二次选中编辑，排出的版面又简约又舒适。（对我而言就是显得更帅一点，哈哈）<br>经过我的测试，不同的软件里集成的markdown语法略有区别，可能是markdown版本不同，例如我使用的markdownpad2就必须在字后面加两个空格才能分段，有道云和简书里直接敲回车就好了，大体上还是一致的。  </p><p>a trick: markdown 是一种标记语言，他名字的由来就是起源于 markup（中文意思‘标记’），类似的情况还包括 copyright 和copyleft（反版权）。</p><p><strong>语法</strong>：<a href="http://wowubuntu.com/markdown/#link/&quot;Markdown&quot;" target="_blank" rel="noopener">参考链接</a></p><p>实例1：展示两种标题语法 </p><p>一种是setext，利用底线形式，“=”是一级标题，“-”是二级标题</p><p>另一种是atx，在行首加入#（1-6个），‘#’数越多题目越大</p><p>区块则是利用“&gt;”来表示，区块还有更全面的使用方式，详情请见<a href="http://wowubuntu.com/markdown/#link/&quot;Markdown&quot;" target="_blank" rel="noopener">参考链接</a> 主要用来引用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A First Level Header</span><br><span class="line">====================</span><br><span class="line">A Second Level Header</span><br><span class="line"><span class="comment">---------------------</span></span><br><span class="line"></span><br><span class="line">Now <span class="keyword">is</span> <span class="keyword">the</span> <span class="built_in">time</span> <span class="keyword">for</span> all good men <span class="keyword">to</span> come <span class="keyword">to</span></span><br><span class="line"><span class="keyword">the</span> aid <span class="keyword">of</span> their country. This <span class="keyword">is</span> just a</span><br><span class="line">regular <span class="built_in">paragraph</span>.</span><br><span class="line"></span><br><span class="line">The quick brown fox jumped <span class="keyword">over</span> <span class="keyword">the</span> lazy</span><br><span class="line">dog's <span class="keyword">back</span>.</span><br><span class="line"><span class="comment">### Header 3</span></span><br><span class="line"></span><br><span class="line">&gt; This <span class="keyword">is</span> a blockquote.</span><br><span class="line">&gt; </span><br><span class="line">&gt; This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="built_in">paragraph</span> <span class="keyword">in</span> <span class="keyword">the</span> blockquote.</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="comment">## This is an H2 in a blockquote</span></span><br></pre></td></tr></table></figure><h1 id="A-First-Level-Header"><a href="#A-First-Level-Header" class="headerlink" title="A First Level Header"></a>A First Level Header</h1><h2 id="A-Second-Level-Header"><a href="#A-Second-Level-Header" class="headerlink" title="A Second Level Header"></a>A Second Level Header</h2><p>Now is the time for all good men to come to<br>the aid of their country. This is just a<br>regular paragraph.</p><p>The quick brown fox jumped over the lazy<br>dog’s back.</p><h3 id="Header-3"><a href="#Header-3" class="headerlink" title="Header 3"></a>Header 3</h3><blockquote><p>This is a blockquote.</p><p>This is the second paragraph in the blockquote.</p><h2 id="This-is-an-H2-in-a-blockquote"><a href="#This-is-an-H2-in-a-blockquote" class="headerlink" title="This is an H2 in a blockquote"></a>This is an H2 in a blockquote</h2></blockquote><p>还有一种方式就是敲一个‘&gt;’ 后面接着打也是一样的</p><blockquote><p>比如这样<br>的下一行还是引用</p></blockquote><p>多个“&gt;&gt;&gt;”代表的层级例如</p><blockquote><p>我是大好人</p><blockquote><p>你是大好人</p><blockquote><p>他是大好人</p></blockquote></blockquote></blockquote><h3 id="修辞、强调与换行及首行空两格"><a href="#修辞、强调与换行及首行空两格" class="headerlink" title="修辞、强调与换行及首行空两格"></a><strong>修辞、强调与换行及首行空两格</strong></h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Some</span> <span class="keyword">of</span> these words *are emphasized*.</span><br><span class="line"><span class="keyword">Some</span> <span class="keyword">of</span> these words _are emphasized also_.</span><br><span class="line"><span class="keyword">Use</span> two asterisks <span class="keyword">for</span> **strong emphasis**.</span><br><span class="line"><span class="keyword">Or</span>, <span class="keyword">if</span> you prefer, __use two underscores instead__</span><br><span class="line">换行=在句子末尾敲多余两个空格+回车</span><br><span class="line">置于首行缩进。。。只有替代方法没有非常方便的方法，例如转成全角敲两个空格或者利用&amp;#<span class="number">160</span>;</span><br><span class="line">(试了一下不理想，还是老老实实敲空格吧)</span><br></pre></td></tr></table></figure><p>Some of these words <em>are emphasized also</em>.<br>Use two asterisks for <strong>strong emphasis</strong>.<br>&#160;Or, if you prefer, <strong>use two underscores instead</strong>  </p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，<strong>记住一个就可以了</strong>，使用星号jia加号和减号：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>Candy.</span><br><span class="line"><span class="bullet">* </span>Gum.</span><br><span class="line"><span class="bullet">* </span>Booze.  </span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>Candy.</span><br><span class="line"><span class="bullet">+ </span>Gum.</span><br><span class="line"><span class="bullet">+ </span>Booze.  </span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Candy.</span><br><span class="line"><span class="bullet">- </span>Gum.</span><br><span class="line"><span class="bullet">- </span>Booze.</span><br></pre></td></tr></table></figure></p><ul><li><p>Candy.  </p></li><li><p>Gum.</p></li><li>Booze.  </li></ul><ul><li>Candy.</li><li>Gum.</li><li>Booze.</li></ul><ul><li>Candy.</li><li>Gum.</li><li>Booze.  </li></ul><p>有序的列表则是使用一般的数字接着一个英文句点作为项目标记，序表也可以进行嵌套：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Red</span><br><span class="line">    <span class="number">1.</span> 嵌套</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> Green</span><br><span class="line"><span class="number">3.</span> Blue</span><br></pre></td></tr></table></figure></p><ol><li>Red  </li><li>Green</li><li>Blue</li></ol><ul><li><p>A list item.</p><p>  asdfasdaasfdasdfsdafasdfadsfdasfdasfasfdadsfgasdgdsagasdgsadgasdgasdgadfdsaffff</p></li><li><p>Another item in the list.</p></li><li>​</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>分为两种： 行内 和 链接  。 都是用角括号<a href=""></a>转换成链接的形式<br>行内形式是直接在后面用括号直接接上链接<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is an [<span class="string">example link</span>](<span class="link">http://example.com/</span>).</span><br></pre></td></tr></table></figure></p><p>This is an <a href="http://example.com/" target="_blank" rel="noopener">example link</a>.  </p><p>你也可以选择性的加上 title 属性(就是鼠标放在链接上面时出现的小框里的字)：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is an [<span class="string">example link</span>](<span class="link">http://example.com/ "With a Title"</span>).</span><br></pre></td></tr></table></figure></p><p>This is an <a href="http://example.com/" title="With a Title" target="_blank" rel="noopener">example link</a>.<br>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [<span class="string">Google</span>][<span class="symbol">1</span>] than from</span><br><span class="line">[<span class="string">Yahoo</span>][<span class="symbol">2</span>] or [<span class="string">MSN</span>][<span class="symbol">3</span>].</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">http://google.com/ "Google"</span></span><br><span class="line">[<span class="symbol">2</span>]: <span class="link">http://search.yahoo.com/ "Yahoo Search"</span></span><br><span class="line">[<span class="symbol">3</span>]: <span class="link">http://search.msn.com/ "MSN Search"</span></span><br></pre></td></tr></table></figure></p><p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from<br><a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>和链接的形式很像,就是在角括号前面需要多加一个“!”<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt text</span>](<span class="link">/path/to/img.jpg "Title"</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/path/to/img.jpg" alt="alt text" title="Title"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在一般的段落文字中，你可以使用反引号`来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I strongly recommend against using any `&lt;blink&gt;` tags.</span><br><span class="line"></span><br><span class="line">I wish SmartyPants used named entities like `&amp;mdash;`</span><br><span class="line">instead <span class="keyword">of</span> decimal-encoded entites like `&amp;#<span class="number">8212</span>;`.</span><br></pre></td></tr></table></figure></p><p>I strongly recommend against using any <code>&lt;blink&gt;</code> tags.</p><p>I wish SmartyPants used named entities like <code>&amp;mdash;</code><br>instead of decimal-encoded entites like <code>&amp;#8212;</code>.</p><p>If you want your page to validate under XHTML 1.0 Strict,<br>you’ve got to put paragraph tags in your blockquotes:</p><p><blockquote></blockquote></p><p></p><p>For example.</p><br><br><code>There is a literal backtick (`) here.</code>  <p></p><p>A single backtick in a code span: <code>`</code></p><p>A backtick-delimited string in a code span: <code>`foo`</code></p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用  标签），你可以在星号的前面加上反斜杠：  </p><p>* literal asterisks * </p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Name |<span class="string"> Academy </span>|<span class="string"> score </span></span><br><span class="line"><span class="string">- </span>|<span class="string"> :-: </span>|<span class="string"> -: </span></span><br><span class="line"><span class="string">Harry Potter </span>|<span class="string"> Gryffindor</span>|<span class="string"> 90 </span></span><br><span class="line"><span class="string">Hermione Granger </span>|<span class="string"> Gryffindor </span>|<span class="string"> 100 </span></span><br><span class="line"><span class="string">Draco Malfoy </span>|<span class="string"> Slytherin </span>|<span class="string"> 90</span></span><br><span class="line"></span><br><span class="line">|<span class="string">    a    </span>|<span class="string">       b       </span>|<span class="string">      c     </span>|</span><br><span class="line">|<span class="string">:-------:</span>|<span class="string">:------------- </span>|<span class="string"> ----------:</span>|</span><br><span class="line">|<span class="string">   居中  </span>|<span class="string">     左对齐    </span>|<span class="string">   右对齐   </span>|</span><br><span class="line">|<span class="string">=========</span>|<span class="string">===============</span>|<span class="string">============</span>|</span><br><span class="line"></span><br><span class="line">打那么多---主要是为了好看。。可以和第一个一样的形式</span><br><span class="line"></span><br><span class="line">作者：欧薇娅</span><br><span class="line">链接：https://www.jianshu.com/p/b03a8d7b1719</span><br><span class="line">來源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c</th></tr></thead><tbody><tr><td style="text-align:center">居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:center">=========</td><td style="text-align:left">===============</td><td style="text-align:right">============</td></tr></tbody></table><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:center">Academy</th><th style="text-align:right">score</th></tr></thead><tbody><tr><td style="text-align:left">Harry Potter</td><td style="text-align:center">Gryffindor</td><td style="text-align:right">90</td></tr><tr><td style="text-align:left">Hermione Granger</td><td style="text-align:center">Gryffindor</td><td style="text-align:right">100</td></tr><tr><td style="text-align:left">Draco Malfoy</td><td style="text-align:center">Slytherin</td><td style="text-align:right">90</td></tr></tbody></table><p>语法说明： </p><ol><li>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行代表一个表格行； </li><li>列与列之间用管道符号 “|” 隔开，原生方式的表格每一行的两边也要有管道符。 </li><li>可在第二行指定不同列单元格内容的对齐方式，默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。</li></ol><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>其实markdown是不支持视频的，现在的通用做法是调用html语言的iframe框架或者插入视频的链接。</p><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是文字……</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> [x] 选项一</span></span><br><span class="line"><span class="ruby">- [ ] 选项二  </span></span><br><span class="line"><span class="ruby">- [ ]  [选项<span class="number">3</span>]</span></span><br></pre></td></tr></table></figure><p>这是文字……</p><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li style="list-style: none"><input type="checkbox"> [选项3]</li></ul><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**<span class="strong">*</span></span><br><span class="line"><span class="strong">---</span></span><br><span class="line"><span class="strong">*</span> * <span class="strong">*</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="*"></a><em>*</em></h2><hr><h3 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h3><p>和链接的方式有点像<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Markdown[^1]</span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">Markdown是一种纯文本标记语言        // 在文章最后面显示脚注</span></span><br></pre></td></tr></table></figure></p><p>Markdown[^1]<br>[^1]: Markdown是一种纯文本标记语言        // 在文章最后面显示脚注</p><h5 id="markdown与法不止这些，但是我看了一下其他的，很繁琐且不常用，建议碰到时在考虑学习，我记录的这些在平常记录或者写写文章就足够用了"><a href="#markdown与法不止这些，但是我看了一下其他的，很繁琐且不常用，建议碰到时在考虑学习，我记录的这些在平常记录或者写写文章就足够用了" class="headerlink" title="markdown与法不止这些，但是我看了一下其他的，很繁琐且不常用，建议碰到时在考虑学习，我记录的这些在平常记录或者写写文章就足够用了"></a>markdown与法不止这些，但是我看了一下其他的，很繁琐且不常用，建议碰到时在考虑学习，我记录的这些在平常记录或者写写文章就足够用了</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-Grammer-Learning&quot;&gt;&lt;a href=&quot;#Markdown-Grammer-Learning&quot; class=&quot;headerlink&quot; title=&quot;Markdown Grammer Learning&quot;&gt;&lt;/a&gt;Markdown Gr
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
      <category term="markdown" scheme="http://sdhmdhr123.github.io/tags/markdown/"/>
    
      <category term="概念" scheme="http://sdhmdhr123.github.io/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://sdhmdhr123.github.io/2018/03/27/hello-world/"/>
    <id>http://sdhmdhr123.github.io/2018/03/27/hello-world/</id>
    <published>2018-03-27T11:29:25.389Z</published>
    <updated>2018-03-27T13:55:27.826Z</updated>
    
    <content type="html"><![CDATA[<p>This blog is a test ,and is my first blog.</p><p>Hello, outside people </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This blog is a test ,and is my first blog.&lt;/p&gt;
&lt;p&gt;Hello, outside people &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Numpy、pandas及matplotlib的使用</title>
    <link href="http://sdhmdhr123.github.io/2018/03/26/h5py/"/>
    <id>http://sdhmdhr123.github.io/2018/03/26/h5py/</id>
    <published>2018-03-26T09:09:55.000Z</published>
    <updated>2018-04-20T07:53:37.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The h5py package is a Pythonic interface to the HDF5 binary data format.</p><p><a href="http://hdfgroup.org/" target="_blank" rel="noopener">HDF5</a> lets you store huge amounts of numerical data, and easily manipulate that data from NumPy. For example, you can slice into multi-terabyte datasets stored on disk, as if they were real NumPy arrays. Thousands of datasets can be stored in a single file, categorized and tagged however you want.</p></blockquote><p>以上是h5py给出的官方解释，这里我们就需要先知道HDF5。</p><blockquote><p>Hierarchical Data Format(HDF)是一种针对大量数据进行组织和存储的文件格式。经历了20多年的发展，HDF格式的最新版本是HDF5，它包含了数据模型，库，和文件格式标准。以其便捷有效，移植性强，灵活可扩展的特点受到了广泛的关注和应用。</p><p>很多大型机构的数据存储格式都采用了HDF5，比如NASA的地球观测系统，MATLAB的.m文件，流体细算软件CDF，都将HDF5作为标准数据格式。现在HDF5还支持了大数据技术和NoSQL技术，并广泛用于科研，金融，以及其他科学和工程领域。</p><p>HDF5在技术上提供了丰富的接口，包含C，C++，Fortran, Python, Java等，能够在不同的语言间完美兼容。</p><p>h5py文件是存放两类对象的容器，数据集(dataset)和组(group)，dataset类似数组类的数据集合，和numpy的数组差不多。group是像文件夹一样的容器，它好比python中的字典，有键(key)和值(value)。group中可以存放dataset或者其他的group。”键”就是组成员的名称，”值”就是组成员对象本身(组或者数据集)，下面来看下如何创建组和数据集。</p><p><strong>1. 创建一个h5py文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> import h5py</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#要是读取文件的话，就把w换成r</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f=h5py.File(<span class="string">"myh5py.hdf5"</span>,<span class="string">"w"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>在当前目录下会生成一个myh5py.hdf5文件</p><p><strong>2. 创建dataset数据集</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> import h5py</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f=h5py.File(<span class="string">"myh5py.hdf5"</span>,<span class="string">"w"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#deset1是数据集的name，（20,）代表数据集的shape，i代表的是数据集的元素类型</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d1=f.create_dataset(<span class="string">"dset1"</span>, (20,), <span class="string">'i'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> key <span class="keyword">in</span> f.keys():</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(key)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].name)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].shape)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].value)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 输出：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> dset1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /dset1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> (20,)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>这里我们仅仅创建了一个存放20个整型元素的数据集，并没有赋值，默认全是0，如何赋值呢，看下面的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> import h5py</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f=h5py.File(<span class="string">"myh5py.hdf5"</span>,<span class="string">"w"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d1=f.create_dataset(<span class="string">"dset1"</span>,(20,),<span class="string">'i'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#赋值</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d1[...]=np.arange(20)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#或者我们可以直接按照下面的方式创建数据集并赋值</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f[<span class="string">"dset2"</span>]=np.arange(15)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> key <span class="keyword">in</span> f.keys():</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].name)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].value)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 输出：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /dset1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /dset2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>​    如果我们有现成的numpy数组，那么可以在创建数据集的时候就赋值，这个时候就不必指定数据的类型和形状了，只需要把数组名传给参数data。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> import h5py</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f=h5py.File(<span class="string">"myh5py.hdf5"</span>,<span class="string">"w"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> a=np.arange(20)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d1=f.create_dataset(<span class="string">"dset1"</span>,data=a)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> key <span class="keyword">in</span> f.keys():</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].name)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].value)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 输出：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /dset1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>现在把这几种创建的方式混合写下。看下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> import h5py</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f=h5py.File(<span class="string">"myh5py.hdf5"</span>,<span class="string">"w"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#分别创建dset1,dset2,dset3这三个数据集</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> a=np.arange(20)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d1=f.create_dataset(<span class="string">"dset1"</span>,data=a)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d2=f.create_dataset(<span class="string">"dset2"</span>,(3,4),<span class="string">'i'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d2[...]=np.arange(12).reshape((3,4))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f[<span class="string">"dset3"</span>]=np.arange(15)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> key <span class="keyword">in</span> f.keys():</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].name)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].value)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 输出：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /dset1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /dset2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [[ 0  1  2  3]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  [ 4  5  6  7]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  [ 8  9 10 11]]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /dset3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>3. 创建group组</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> import h5py</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f=h5py.File(<span class="string">"myh5py.hdf5"</span>,<span class="string">"w"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#创建一个名字为bar的组</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> g1=f.create_group(<span class="string">"bar"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#在bar这个组里面分别创建name为dset1,dset2的数据集并赋值。</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> g1[<span class="string">"dset1"</span>]=np.arange(10)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> g1[<span class="string">"dset2"</span>]=np.arange(12).reshape((3,4))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> key <span class="keyword">in</span> g1.keys():</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(g1[key].name)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(g1[key].value)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 输出：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bar/dset1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bar/dset2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [[ 0  1  2  3]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  [ 4  5  6  7]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  [ 8  9 10 11]]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>注意观察数据集dset1和dset2的名字是不是有点和前面的不一样，如果是直接创建的数据集，不在任何组里面，那么它的名字就是/+名字，现在这两个数据集都在bar这个group(组)里面，名字就变成了/bar+/名字，是不是有点文件夹的感觉！继续看下面的代码，你会对group和dataset的关系进一步了解。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> import h5py</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> import numpy as np</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> f=h5py.File(<span class="string">"myh5py.hdf5"</span>,<span class="string">"w"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#创建组bar1,组bar2，数据集dset</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> g1=f.create_group(<span class="string">"bar1"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> g2=f.create_group(<span class="string">"bar2"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d=f.create_dataset(<span class="string">"dset"</span>,data=np.arange(10))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#在bar1组里面创建一个组car1和一个数据集dset1。</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> c1=g1.create_group(<span class="string">"car1"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d1=g1.create_dataset(<span class="string">"dset1"</span>,data=np.arange(10))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#在bar2组里面创建一个组car2和一个数据集dset2</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> c2=g2.create_group(<span class="string">"car2"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> d2=g2.create_dataset(<span class="string">"dset2"</span>,data=np.arange(10))</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#根目录下的组和数据集</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(<span class="string">"............."</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> key <span class="keyword">in</span> f.keys():</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(f[key].name)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#bar1这个组下面的组和数据集</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(<span class="string">"............."</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> key <span class="keyword">in</span> g1.keys():</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(g1[key].name)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#bar2这个组下面的组和数据集</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(<span class="string">"............."</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> key <span class="keyword">in</span> g2.keys():</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="built_in">print</span>(g2[key].name)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#顺便看下car1组和car2组下面都有什么，估计你都猜到了为空。</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(<span class="string">"............."</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(c1.keys())</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">print</span>(c2.keys())</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 输出：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> .............</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bar1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bar2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /dset</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> .............</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bar1/car1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bar1/dset1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> .............</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bar2/car2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /bar2/dset2</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> .............</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> []</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> []</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;The h5py package is a Pythonic interface to the HDF5 binary data format.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hdfgroup.org/&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="参考" scheme="http://sdhmdhr123.github.io/categories/%E5%8F%82%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>利用Github+hexo+next建立个人博客</title>
    <link href="http://sdhmdhr123.github.io/2018/03/26/%E5%88%A9%E7%94%A8github-hexo-next%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://sdhmdhr123.github.io/2018/03/26/利用github-hexo-next建立个人博客/</id>
    <published>2018-03-26T01:31:03.000Z</published>
    <updated>2018-03-27T13:59:46.754Z</updated>
    
    <content type="html"><![CDATA[<p>建立个人博客的经历真是很多很多坑啊…如果顺利的话，正常人应该两个小时就足够了，我是各种手贱折腾，捣鼓了好多天才弄完，emm…我就顺便记录一下我还记得的坑把。<br>你只需要按照我的步骤走就肯定没问题，可能你看到hexo，git什么不太懂，我会在步骤之间把其中涉及的概念我会一一解释。</p><p>首先是用自己的github（github我就不解释了啊，查阅百度，我感觉就是一个存代码的网盘，不过可以通过时间线查看版本）建立一个repository，这个就是我们存放我们博客的文件夹啦。 </p><p><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic1.png?raw=true" alt="1"></p><p>这里注册的仓库名要注意了，同学们，如果呢你想让你的博客网站叫做 yourgithubid.github.io 就要起和你的yourgithubID一样的名字的仓库，即repository name 填 username.github.io，如果呢你不在乎或者有买一个域名绑定的打算，就可以忽略，随便起一个random.github.io 之后访问可能就是这个网址了 yourgithubID.github.io/random.github.io. </p><p>建好了之后先放着，去搞hexo，hexo是一个快速简洁高效的静态博客框架，这里静态动态的意思就是，静态不会出现信息的交互，例如一直更新的天气天气预报，新闻啊啥的，存一部分乱七八糟一股脑扔到网上就不管了。博客也基本不需要动态，所以hexo是最佳选择，其实还可以用jekyll(不好用，教程少，hexo大法好)。<br>安装hexo之前得安装点hexo的环境，因为hexo是node.js编的，所以得把这个东西装上，例如你运行python脚本得装python吧。然后还要装Git，这个东西呢类似你的cmd，但是继承了一些linux shell的本领以及一些他git自己的命令，你可以忽略直接无脑装装装。</p><ul><li><a href="nodejs.org/">node.js</a></li><li><a href="git-scm.com">Git</a><br>安装完成之后，剩下就直接粘代码进git bash 里就好了。</li></ul><p>(妈的，markdown插图片真的贼鸡儿麻烦，得考虑一下别的编辑方法了)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure></p><p>可以参照官方文档安装node.js 和git 官方文档也有 </p><p><a href="hexo.io/zh-cn/docs/">hexo</a></p><p>好了，这时候看一下你的hexo安装成功了没有,在gitbash里<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$hexo</span></span></span><br></pre></td></tr></table></figure></p><p>看一下有木有东西，有东西就安装成功了，没东西你自己在翻翻文档。</p><p>下一步：建站  </p><p>名字挺唬人，其实就是建个文件夹。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init myGitPages</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myGitPages</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure></p><p>运行完之后，会出现很多文件和文件夹<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic3.png?raw=true" alt="3"><br>介绍一下主要的，themes是主题文件夹，网上有很多，我用的是next，这个一会再说。source就是你将会往你的github传的文件啦，文章图片啥的，_config.yml 是配置文件，你可以通过编辑这个文件来个性化你的博客，具体细节呢，我先写写看再决定写不写。package.json是应用程序信息。有默认配置的一些组件，可以自己根据需要添加或移除，反正我是看不懂json..就不改了。<br>scaffolds 模板文件夹。建立新文章时，hexo会根据scaffold来建立文件。其他的我也不知道干啥用的，不重要（但是不能删）。<br>好了基本弄完了，剩下的主题，你可以根据自己需要下载，hexo官网有很多，但是我感觉大部分人用的都是yilla和next，就以next为例。<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a><br>这里面有详细的使用说明，我就不细说了。<br>嗯 最后，就是要发布文章了，先杆状一个插件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure></p><p>这个插件是用来发布到git上的。<br>然后<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #形成</span><br><span class="line">hexo<span class="built_in"> server </span>#用来本地预览，这运行完会出现一个网址，你把它粘到网站里运行一下试试。 大概是localhost：4000 这种样子的。</span><br></pre></td></tr></table></figure></p><p>如果预览成功，好这还不算完，由于你要往网上传东西，你得得到人家github许可才行呀，所以接下来就是要做git的身份认证。<br><strong>SSH授权</strong><br>打开gitbash 输入ssh-keygen -t rsa 连敲三下回车<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic4.png?raw=true" alt="4"><br>这样就会在C盘用户目录下生成id_rsa和id_rsa.pub这两个文件，前者是密钥，后者是公钥，用记事本打开id_rsa.pub，复制其中的全部内容，添加到GitHub上，这样本地的id_rsa密钥就可以和GitHub上的id_rsa.pub公钥进行配对，授权成功<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic5.jpg?raw=true" alt="5"><br>SSH key添加之后，就可以在本机git bash中进行测试，输入ssh -T git@github.com进行测试，<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic6.png?raw=true" alt="6"><br>返回Hi username ！You’ve successfully ……说明你已经成功啦！</p><p><strong>修改上传设定</strong><br>还记得文件夹里的_config.yml吗<br>打开它，修改 （主义冒号后面必须跟空格）<br>deploy:<br>    type: git<br>    repo：<a href="https://github.com/username/username.github.io.git" target="_blank" rel="noopener">https://github.com/username/username.github.io.git</a><br>然后发布就可以了<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo <span class="keyword">generate</span> &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></p><p>第一次访问可能需要密码。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>我在测试各个主题的时候碰到了很多问题，例如next老师莫名崩溃说找不到什么/.swig，后来发现就是更改_config.yml时候格式不标准就GG了，所以你在改这些格式的时候，要千万注意，必须严格按照要求。</p><p>其实还有很多很细节的东西，我实在是懒得写了,都没时间搞科研了…以后如果碰到这种有很多教程的东西，我还是直接粘过来把，不过图片没法粘贴是个问题，再说再说，但是我可以帮忙回答遇到的问题，如果有人看的话。。。。。</p><p><strong><em>如果有什么问题可以留意问我哦~</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建立个人博客的经历真是很多很多坑啊…如果顺利的话，正常人应该两个小时就足够了，我是各种手贱折腾，捣鼓了好多天才弄完，emm…我就顺便记录一下我还记得的坑把。&lt;br&gt;你只需要按照我的步骤走就肯定没问题，可能你看到hexo，git什么不太懂，我会在步骤之间把其中涉及的概念我会一
      
    
    </summary>
    
      <category term="学习" scheme="http://sdhmdhr123.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="github" scheme="http://sdhmdhr123.github.io/tags/github/"/>
    
      <category term="hexo" scheme="http://sdhmdhr123.github.io/tags/hexo/"/>
    
      <category term="next" scheme="http://sdhmdhr123.github.io/tags/next/"/>
    
      <category term="博客" scheme="http://sdhmdhr123.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>每天一点点（一）</title>
    <link href="http://sdhmdhr123.github.io/2018/03/26/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://sdhmdhr123.github.io/2018/03/26/每天一点点（一）/</id>
    <published>2018-03-26T00:28:38.000Z</published>
    <updated>2018-03-27T14:04:14.033Z</updated>
    
    <content type="html"><![CDATA[<p>1.「rise」：在文中指“站起来，起立”，常见意思为“上升，增长”。</p><p>原句：The gentleman half rose from his chair to greet me.  </p><p>2.「nature」：在文中的意思为“本质、性质”，常见意思为“自然”。  </p><p>原句：But also because the highly unusual nature of the story makes me…<br>例句：They asked a lot of questions about the nature of our democracy.(民主主义)<br>democratic democray democrat democratize  </p><p>3.「puff」：在文中与out组成词组「puff out one’s chest」，表示“挺起胸膛”常见意思为“喘粗气、使膨胀”。</p><p>原句：The client puffed out his chest with an appearance of some pride…<br>例句:  Henry puffed out his chest proudly.<br>Kim Sanpang puffed out his chest proudly with clapping his hands.</p><p>4.「immediately」在文中的意思是“紧靠地、贴近地”，常见的意思为“立刻，马上”。</p><p>原句：The fish that you have tattooed immediately above your right wrist( 手腕 ) could only have been done in China.<br>例句：He sat in the seat immediately in front of me. </p><p><strong><em>句子解析</em></strong></p><ol><li>“I know, my dear Watson, that you share my love of all / that is outside the normal routine of everyday life. You have shown your relish for it by the enthusiasm /which has prompted you/ to write down and, if I may say so, somewhat to embellish so many of my own little adventures.” </li></ol><p>prompt：迅速敏捷的， 促进激励  付款期限温馨提示<br>relish： 食欲 开胃小菜 调味品 盼望期待享受品味加作料  </p><p>第一句话中：「share」表示“共同拥有（某种看法、特质或经济）”，「share my love of all」则可以理解为“你同我一样喜欢”。</p><p>第二个「that」 引导的从句是修饰前面的「my love of all」。</p><p>所以这句话大意为：亲爱的Watson，我知道你同我一样喜欢破案，而不是那些日常生活中的俗套。</p><p>第二句话中：「show relish for something」表示“对…感兴趣，表现出对…的喜爱”。文中即：你对它（破案）很感兴趣。</p><p>「which」引导的从句是修饰「you have…enthusiasm」，在which从句中，「prompt sb. to do sth.」表示“激励（促使）某人做某事”。文中即：…促使你满腔热情地把这些东西都记录下来。</p><p>「if I may say so」是插入语，表示“如果我可以这样说；如蒙允许”。文中即：如果你不介意的话，我要说，你这样做是为我自己的许多小小的冒险事业增添光彩（embellish）。</p><p>所以这句话的大意为：你那么满腔热情地把这些东西都记录下来，可见你对它们很感兴趣。如果你不介意的话，我要说，你这样做是为我自己的许多小小的冒险事业增添光彩。</p><ol><li>“You will remember my saying the other day,/that for strange effects and extraordinary events, we must go to life itself, /which is always far more daring than any effort of the imagination.” </li></ol><p>这句话的主干为：You will remember my saying the other day. 即：你应该记得前几天（the other day）我说的那段话吧。</p><p>that从句部分是补充说明前面的「my saying」，其中which引导的从句是修饰前面的life itself，即：生活本身远比任何大胆想象更富有冒险性（daring）。</p><p>所以that从句部分的大意为：为了获得新奇的（strange）效果和不同寻常的（extraordinary）事件，我们必须深入生活，因为生活本身远比任何大胆想象更富有冒险性（daring）。</p><p>这段话是 Sherlock 跟Watson 对于创作与生活的一些探讨，而 Watson 对此观点暂时是持怀疑态度的，所以他后面说他当时斗胆持怀疑态度（being brave enough to express some doubts）。</p><ol><li>You have heard me remark/ that the strangest examples are very often connected not with the larger but with the smaller crimes, /and occasionally occur in cases/ where there is room for doubt /as to whether there has been a crime at all. </li></ol><p>这句话的主干为：You have heard me remark. 即：你已经听我说过（remark）… ；</p><p>在从句部分「that the strange … a crime at all」中，包含由and 构成的两个并列句子：</p><p>（1）「be connected not with…but with…」表示“和……无关，而和……有关”。其中「not…but…」表示“不是…而是…”。这句话的大意为：最奇怪的事件通常都不是那些大的犯罪活动，而是那种不起眼的犯罪。</p><p>（2）「and occasionally…crime at all」的主干为：and occasionally occur in cases. 即：而且偶尔有这样的案件。</p><p>where 引导的从句是修饰cases，其中「room」表示“可能性、余地”。「there is room for doubt as to …」则表示“对…存有疑虑，怀疑…”。文中即：怀疑是否真的有人犯了罪。</p><p>所以这句话的大意为：而且偶尔会有这样的案件，而你怀疑是不是真的有人犯了罪。</p><ol><li>“Beyond the obvious facts / that he has at some time done manual labor, that he is a Freemason, that he has been in China, and that he has done a lot of writing lately, / I can deduce nothing else.” </li></ol><p>这句话的主干为：Beyond the obvious facts I can deduced nothing else. 「beyond」表示“除…之外（用于否定句）”，这句话的意思是：除了这些显而易见的（obvious）情况之外，我推断不出别的。</p><p>「that he has… writing lately」其中包含由that引导的从句，都是解释说明「the obviously facts」，即：他干过一段时间的体力活（manual labor），是个共济会会员（Freemason），去过中国，最近（lately）写过不少东西。</p><p>拓展：「Freemason」指的是一个遍布全球的叫做 Freemasonry 的兄弟会的成员，大约18世纪的时候，一些石匠组织起了这个兄弟会，刚开始是工作上的交流，慢慢地变成了社交组织。一般这种组织都会有很多规则要遵守，而且还会有一些秘密活动或者仪式，还有个有趣的点，就是Sir Arthur Conan Doyle本人也是 Freemasonry 的成员。下图是一个典型的 Freemasonry 的标志：<br><img src="https://github.com/sdhmdhr123/Aston.github.io/blob/master/uploads/pic.jpg?raw=true" alt="1"></p><p>I won’t insult your intelligence by telling you how I read that, especially as, rather against the strict rules of your organization, you use an arc-and-compass breastpin.</p><p>前半句中「insult」表示“侮辱”，文中即“我不想告诉你我是如何看出来的，这会侮辱你的智商(intelligence)”</p><p>扩展一下：「insult」也可以做名词，表示“侮辱、冒犯”。e.g. Some advertising is an insult to our intelligence. 有些广告对我们的智商是一种侮辱。</p><p>「against rules」表示违反规则，这里是说“尤其（rather）违反你们组织规则…”。</p><p>当被客户问到 Sherlock 是如何看出他是 Freemason 的时候，Sherlock 说我不想侮辱您的智商，但是您看看您不顾你们组织的严格规定，把这个圆规加直尺（共济会的标志）一样的胸针戴出来了。看来我们的Wilson 先生并不是个严格遵守共济会规定的人。</p><ol><li>TO THE RED-HEADED LEAGUE:<br>the will of the late Ezekiah Hopkins<br>…at the offices of the League, 7 Pope’s Court, Fleet Street. </li></ol><p>Wilson 先生拿出了报纸上刊登的一篇广告，说是根据已故的 Ezekiah Hopkins 的遗愿，有一个职位空缺需要招一个红头发、身心健康、21岁以上的男士，然后写上了面试的时间地点。</p><p>「late」在这里指”已故的”，比如 her late husband，她已故的丈夫；Fleet Street 这个地址是真实存在的，但现在已经找不到 Pope’s Court；另外广告中提到的 4 pounds a week 的工资，相当于现在400英镑的周薪，难怪Wilson会被这个广告吸引。1英镑=8.8857人民币元。</p><ol><li>“It is The Morning Chronicle of April 27, 1890. Just two months ago.” </li></ol><p>Sherlock 让 Watson 看看报纸的名字和日期。这里出现了写作上的一个时间偏差，报纸是4月27号的，Watson 说是两个月前的报纸，但文章开头说是秋季里的某一天，明显6月底不会是伦敦的秋季。</p><ol><li>I have a small pawnbroker’s business at Coburg Square, near the City. It’s not a very large one, and in the last few years it has not done more than just give me a living.</li></ol><p>「have a business」表示“做生意”，这句话的大意为：我在市区附近的Coburg广场做当铺生意（pawnbroker’s business）。</p><p>第二句话中：「one」指代business。not more than表示“仅仅、只不过”。这句话的大意为：生意规模不大，在过去几年仅仅可以维持生计而已。 </p><ol><li>You seem most fortunate in having an employee /who will take less than the full market price. It is not a common experience among employers. </li></ol><p>第一句话中：「be fortunate in doing sth」表示“做某事很幸运”。e.g. She felt fortunate in being able to please herself where she lived. 在自己住的地方能够随心所欲，她觉得很幸运。</p><p>who引导的从句是修饰前面的「employee」，这句话的大意为：你能以低于（less than）市价的工钱雇到一个伙计（employee），看起来可是非常幸运了。</p><p>第二句话「It is …employers.」的大意为：这在像你这样年纪的雇主（employer）当中，可不是一个寻常的事。</p><p>当说到自己的一个伙计愿意只拿一半工资，也要留在当铺工作的时候，Sherlock 说 Wilson 特别幸运（most fortunate），居然找到一个愿意拿比市价少的工资的员工，这样的经历大多数老板可不会遇到。所以 Sherlock 也关注到了这个不同寻常的现象。</p><ol><li>“He is always taking photographs when he ought to be improving his mind, and then diving down into the cellar like a rabbit into its hole to develop his pictures.</li></ol><p>「improve one’s mind」表示“振作精神”，在文中可以理解为“好好看守当铺”。文中即：当他本应好好看当铺的时候，他却总是在摄影拍照。</p><p>「like a rabbit into its hole」表示“动如脱兔”。「develop」在文中表示“冲洗”，常见的意思为“发展，形成”。文中即“然后像兔子跳回窝里一样似的冲到地下室冲洗胶片”。</p><p>这段话运用了比喻，生动形象的表现出Spaulding冲到地下室的急切之情。当他本应该振作精神（好好看当铺时候）他却总是在摄影拍照，然后像兔子跳回窝里一样似的冲到地下室冲洗胶片。</p><ol><li>We live very quietly, sir, the three of us; and we keep a roof over our heads and pay our debts, if we do nothing more. </li></ol><p>「keep a roof over our heads」 在文中可理解为“住在一个房檐下，一起生活”</p><p>【if we do nothing more】 则表示“除此之外没别的了”。</p><p>这段话的大意为：我们三个人一起过着安静的生活；我们住在一起，一起还债（pay our debts），除此之外没有别的了。</p><p><strong><em>今日短语</em></strong></p><p>call upon sb 拜访某人<br>be connected not with…but with… ，和……无关，而和……有关<br>occur in cases ，还有种情况是……<br>there is room for doubt… ，在……方面存有疑虑 。<br>far from 远离；远非；完全不<br>puff out one’s chest  挺起胸膛<br>to the best of my belief 据我所知<br>on account of sth 由于，因为..<br>out of ordinary 不寻常<br>a roof over one’s head 住处，栖身之处</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.「rise」：在文中指“站起来，起立”，常见意思为“上升，增长”。&lt;/p&gt;
&lt;p&gt;原句：The gentleman half rose from his chair to greet me.  &lt;/p&gt;
&lt;p&gt;2.「nature」：在文中的意思为“本质、性质”，常见意思
      
    
    </summary>
    
      <category term="感悟" scheme="http://sdhmdhr123.github.io/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="英语" scheme="http://sdhmdhr123.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
</feed>
