<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2FAston.github.io%2F2018%2F03%2F25%2F%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面相对象编程对象（object）广义上是指内存上一段有意义的区域。狭义上是指把一组数据结构和处理他们的方法结合起来叫做对象。把相同行为的对象叫做类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）/泛化(generalization)，通过多态（polymorphism）实现基于对象类型的动态分派。面相对象（objected oriented）类：可以理解为可以量产对象，但是产生的可以不同封装：就是知道名字可以使用，但是具体怎么实现的不知道继承：子类能继承父类的功能例如12345class Mylist(list): passa = Mylist()a.append(5)这里Mylist 就继承了list的功能。 目前就我的理解，可以把类比作汽车，那停和启动就是方法，函数中通常不会封装数据，只是执行某种功能但是类中有。多态：是同一个功能函数在不同的类里执行的功能可能不同（我感觉这就是废话，为什么会当成一个特征。）python中的类的self其实就是相当于c++的this指针，对象自身会当做第一个参数传给self，self相当于每个房子的门牌号。类相当于设计图纸。对象就是长得很像但不是一个的房子。类：都是人，对象：但人又都不相同类中可以内置一些方法，用双下横线包围__init__(self，param1,param2=&#39;example&#39;)你不写他也有个__init__(self)和c++的构造函数一样name mangling:在私有变量或者函数前面加上两个_就可以了1234class Person: __name ="小甲鱼" def getName(self): returen self.__name 直接调用 p.name是不行的用p.getName() p._Personname就行 python类没有权限控制，所以是伪私有。 123class Turtle: def climb(self): print('ddasdfa') 当程序员不想把同一段代码写几次，他们发明了函数解决了这种情况。当程序员已经有了一个类，而又想建立一个非常相近的类，可以用继承的方法。 self是对象自身作为的第一个参数传入。 如果我们不希望对象的属性和方法被外部直接引用，我们可以设置私有变量或者函数，但实际上还是引用的到。 类在实例化后init(self)函数会被自动调用，init 是initialize的缩写。 继承中,子类方法如果和父类方法（即函数）重名，则子类方法会把父类方法给覆盖掉。所以这里面有两种技术可以实现不覆盖。一种是Fish.__init__(self)调用父类fish，其实就等于Fish.__init__(shark),shark 是子类方法。另一个更好用得是super(),多重继承时特别好用。super.__init__()多重继承虽然很好用，但是容易引起代码混乱，所以在不确定的时候，最好不要用多重继承，会造成不可预见的bug，例如菱形继承或者叫做钻石继承，这个很致命。 继承机制为程序员带来的明显的好处就是写的代码量少了。 当子类定义了与父类相同名字的属性或方法时，python不会删除父类的方法或属性，但在对象调用子类继承父类时，其父类的方法或属性会被子类方法或属性给覆盖。 如果要屏蔽父类中的某些属性，利用覆盖机制就可以，将那条方法写在子类后面，写一个pass就可以 super超级的地方就在于不用再将父类的名字再打一遍，而且适用于多重继承。同时，由于你不用给出基类的名字，这就意味着如果你需要改变类继承关系，你只需要改变class里的父类即可。而不用去各个代码中寻找父类的名字。 init(self)方法里不能有return ，因为这个方法不能反悔除None以外的任何对象，主要是用来给一些初始化定义。 1234567891011121314151617181920212223242526import mathclass Point(): def __init__(self, x=0, y=0): self.x = x self.y = y def getX(self): return self.x def getY(self): return self.yclass Line(): def __init__(self, p1, p2): self.x = p1.getX() - p2.getX() self.y = p1.getY() - p2.getY() self.len = math.sqrt(self.x*self.x + self.y*self.y) def getLen(self): return self.lenp1 = Point(1, 1)p2 = Point(4, 5)line = Line(p1, p2)print(line.getLen()) 上面代码中并没有用到继承，传入line的是两个对象，对象自带属性和方法，在传入其他类后对其进行操作时可直接调用对象的方法和属性。 ###组合组合是指把没有直接关系的类放在一起叫做组合, in another word,所谓组合就是把类和实例化放在一个新的类里面，这样就不用继承了。123456789101112class Turtle: def __init__(self,x): self.num = xclass Fish: def __init__(self,y):class Pool: def __init__(self,x,y): self.turtle = Turtle(x) self.fish = Fish(y) def print_num(self): print("there were %d turtles and %d fish"%(self.turtle.num,self.fish.num)) 这里不能直接用self.turtle, 因为 self.turtle = Turtle(x) 是一个实例化对象，并不是一个实际的方法或属性 ###Min-in 编程机制 mixin 是一种开发模式，是一种将多个类中的功能单元进行组合利用的方式，这听起来有点像类的继承，但是不太一样。通常mixin不作为任何类的基类，也不关心和什么类一起使用，而是在运行时动态的同其他的零散的类一起组合使用。 下面提到的多继承和bases方法都是基于这个机制。 ####多继承Python支持多继承，即一个子类可以继承多个父类，利用这个特性，我们就可以利用mixin机制实现ab功能的组合。 ####bases ：一种类的组合机制多继承的实现会创建出新的类，在我们希望给A类添加B类的功能时，我们可以利用python元编程特性实现。元编程meta-programming（这古文翻译，不懂古文的还真有点看不懂），写用来生成代码的代码。感觉就是一种手工压缩代码量的感觉，元编程操作的对象是其他代码。继续说多继承，举个栗子：1234567891011121314151617class A: def get_a(self): print 'a'class B: def get_b(self): print 'b'class C(A, B): passc = C()c.get_a()c.get_b()A.__bases__ += (B,)a.get_b() 其实bases也是继承的机制，，因为bases属性存储了类的基类。因此多继承的方法也可以这样实现。12345class C: passC.__bases__ += (A, B, ) 还有另一种方式：插件方式，比较麻烦，如果用到，再看不迟dict。参考链接 类、类对象和实例对象。类属性和类对象相互绑定，所以实例对象改变不会影响类对象，实例对象改变会覆盖类方法1234567891011121314151617181920212223class C: count = 0a=C()b=C()c=C()a.count0b.count0c.count0c.count+=10c.count0C.count0C.count+=100a.count100b.count100c.count10 一个整形是不能调用的，属性名和方法名相同，属性会覆盖方法。 类的定义要少吃多餐，不要在一个类中放上所有想到的方法和属性，尽量利用继承和组合机制进行扩展类。 有不同的磁性的名字命名类。名词动词词性分开。 1234567&gt;&gt;&gt; c = C()&gt;&gt;&gt; c.x =1&gt;&gt;&gt; c.x()Traceback (most recent call last): File "&lt;pyshell#24&gt;", line 1, in &lt;module&gt; c.x()TypeError: 'int' object is not callable 什么时候用组合，什么时候用继承？根据实际的应用场景确定。简单地说，组合适用于“有一个”的场景，继承适用于“是一个”的场景。例如有一个鱼，有一个猫有一个大象。鲨鱼是鱼，青瓜是瓜。 类对象是什么时候产生的？-当你这个类定义完的的时候，类定义就变成类对象。python是一切皆对象，可以用‘类名.属性’或‘类名.方法’来调用类对象。 ####设计一个跟踪一个类里有多少实例被创建的代码1234567891011121314151617181920class C: count = 0 def __init__(self): C.count += 1 def __del__(self): C.count -= 1 #实际上我不懂这一段代码&gt;&gt;&gt; a = C()&gt;&gt;&gt; b = C()&gt;&gt;&gt; c = C()&gt;&gt;&gt; C.count3&gt;&gt;&gt; del a&gt;&gt;&gt; C.count2&gt;&gt;&gt; del b, c&gt;&gt;&gt; C.count0 ###与类相关的BIF（内置函数）issubclass(class,classinfo)一个类是自身的子类；classinfo可以使类对象组成的元组，只要class与其中任何一个候选类的子类，则返回True object 是所有类的子类issubclass(B,object) isinstance(object,classinfo)检查是否是实例对象第一个如果不传入实例对象，全是false可以传入一个元组类 BIF 比较斯文的访问属性hasattr(object,’name’)getattr(object,name[,default])getattr(a,’x’,’你所访问的属性不存在’)setattr(object,’name’,’value’)delattr(object,’name’)property(fget =None,fset=None,fdel=None,doc =None) 返回值是一个属性a = property(getsize,setsize,delsize)123c.a = 18 del c1.a c.a property 主要功能是提供一个借口，再调用是只需要知道 a 不用知道里面改变了啥。 ###描述符描述符就是将某种特殊类型的类的实例指派给另一个类的属性。get set del是特殊类型property就是一个描述符类。可以自己定义一个instance 是实例拥有者的实例对象，owner 是实例拥有者12345678910111213141516171819202122class Myproperty: def __init__(self,fget = None,fset=None,fdel =None): self.fget=fget self.gset = gset self.del=fdel def __get__(self,instance,owner): #不赋值直接调用时 reutrn self.fget(instance) def __set__(self,instance,value): #赋值时所调用的 self.fset(instance,value) def __delete__(self,instance): self.fdel(instance)class C: def __init__(self): self._x = None def getX(self): return self._x def setX(self,value): self._x=value def delX(): del self._x x = Myproperty(getX,setX,delX)#可以说myproperty是x的描述符 class myproperty（）是描述符类 12345678910111213141516171819202122class Celsius: def __init__(self,value=26.0): self.value=float(value) def __get__(self,instance,owner): return self.value def __set__(self,instance,value): self.value = float(value)class Fahrenheit(): def __get__(self,instance,owner): return instance.cel*1.8+32 def __set__(self,instance,value): instance.cel = (float(value)-32)/1.8class Temperature: cel = Celsius() fah = Fahrenheit()tmp=Temperate()tem.cel= 30 这是对Tem实例的cel属性进行赋值执行__set__方法然后instance.cel也就是是tem.cel也就是说这里面赋值其实都是给cel ，fah执行的只是给这个数进行了转换 定制序列协议与其他编程语言中的接口相似，他规定你哪些方法必须要定义。然而python中更像是一种指南。定制序列就是定制容器，数据容器就是列表list，词典dict，元组tuple.如果你希望你的容器不可修改你只需要定制 len() and getitem()如果你希望你的容器可修改还得加上setitem() and delitem()[x for x in arg]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FAston.github.io%2F2018%2F01%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[This is my house]]></content>
  </entry>
</search>
